#!/bin/bash
#
# FC-1 Remote Control Script
# Run from host machine to control FC-1 on target
#
# Usage: ./fc1 [-d destination] [start|stop|restart|status|enable|disable|run|log|cmd|config|deploy|push|ssh]
#

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
TARGET_HOST="192.168.7.1"
TARGET_PORT="22222"
TARGET_USER="root"
TARGET_PASS="PasswordQConnect"

# Parse optional -d argument
if [ "$1" = "-d" ] && [ -n "$2" ]; then
    TARGET_HOST="$2"
    shift 2
fi

# Remote script location
REMOTE_SCRIPT="/tmp/fc1_service.sh"
LOCAL_SCRIPT="${SCRIPT_DIR}/fc1_service.sh"

# Binary paths
LOCAL_BINARY="${SCRIPT_DIR}/../Fleet-Connect-1/build/FC-1"
REMOTE_BINARY="/usr/qk/bin/FC-1"

# Expect tools paths
# Deploy to /usr/qk/etc/sv/FC-1/expect/ which is persistent across reboots
# (unlike /usr/local which may be volatile on embedded systems)
EXPECT_PACKAGE="${SCRIPT_DIR}/../external_tools/build/expect-arm.tar.gz"
EXPECT_CMD_SCRIPT="${SCRIPT_DIR}/fc1_cmd.exp"
REMOTE_EXPECT_DIR="/usr/qk/etc/sv/FC-1/expect"
REMOTE_EXPECT_CMD="/tmp/fc1_cmd.exp"

# OS Upgrade Configuration
LATEST_OS_VERSION="4.0.0"
UPGRADE_DIR="${SCRIPT_DIR}/../quake_sw/rev_4.0.0"
UPGRADE_DIR_512MB="${UPGRADE_DIR}/OSv4.0.0_512MB"
UPGRADE_DIR_128MB="${UPGRADE_DIR}/OSv4.0.0_128MB"
REMOTE_UPGRADE_DIR="/root"
MEMORY_THRESHOLD_KB=509740  # 512MB threshold

# SSH command with options (using arrays to avoid eval issues with special chars)
SSH_OPTS=(-p "${TARGET_PORT}" -o StrictHostKeyChecking=no -o ConnectTimeout=10)
SCP_OPTS=(-P "${TARGET_PORT}" -o StrictHostKeyChecking=no)
# Legacy string versions for backwards compatibility with existing code
SSH_CMD="sshpass -p '${TARGET_PASS}' ssh -p ${TARGET_PORT} -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${TARGET_USER}@${TARGET_HOST}"
SCP_CMD="sshpass -p '${TARGET_PASS}' scp -P ${TARGET_PORT} -o StrictHostKeyChecking=no"

# Check if sshpass is installed
check_sshpass() {
    if ! command -v sshpass &> /dev/null; then
        echo "Error: sshpass not installed"
        echo "Install with: sudo apt-get install sshpass"
        exit 1
    fi
}

# Clear SSH known_hosts entry for target (handles host key changes)
clear_host_key() {
    echo "Clearing old SSH host key for [${TARGET_HOST}]:${TARGET_PORT}..."
    ssh-keygen -f "$HOME/.ssh/known_hosts" -R "[${TARGET_HOST}]:${TARGET_PORT}" 2>/dev/null
}

# Check if target is reachable and SSH works
check_target() {
    if ! ping -c 1 -W 2 "$TARGET_HOST" &> /dev/null; then
        echo "Error: Cannot reach target at $TARGET_HOST"
        exit 1
    fi

    # Test SSH connection and check for host key issues
    SSH_TEST=$(eval $SSH_CMD "echo ok" 2>&1)
    if echo "$SSH_TEST" | grep -q "REMOTE HOST IDENTIFICATION HAS CHANGED"; then
        echo "Device changed detected - host key mismatch"
        clear_host_key
        echo "Retrying connection..."
        SSH_TEST=$(eval $SSH_CMD "echo ok" 2>&1)
    fi

    # Check if it's a host key verification issue
    if echo "$SSH_TEST" | grep -q "Host key verification failed"; then
        clear_host_key
        echo "Retrying connection..."
        SSH_TEST=$(eval $SSH_CMD "echo ok" 2>&1)
    fi

    # Success if output contains "ok" (may also have banner/warnings)
    if ! echo "$SSH_TEST" | grep -q "^ok$"; then
        echo "Error: SSH connection failed"
        echo "$SSH_TEST"
        exit 1
    fi
}

# Deploy script to target
deploy_script() {
    echo "Deploying fc1_service.sh to target..."
    eval $SCP_CMD "$LOCAL_SCRIPT" "${TARGET_USER}@${TARGET_HOST}:${REMOTE_SCRIPT}"
    eval $SSH_CMD "chmod +x ${REMOTE_SCRIPT}"
    echo "Deployed to ${REMOTE_SCRIPT}"
}

# Push built binary to target
# Usage: push_binary [-run]
push_binary() {
    local start_service=false
    if [ "$1" = "-run" ]; then
        start_service=true
    fi

    if [ ! -f "$LOCAL_BINARY" ]; then
        echo "Error: Binary not found at $LOCAL_BINARY"
        echo "Run 'make' in Fleet-Connect-1/build first"
        exit 1
    fi

    echo "Stopping FC-1 service..."
    run_remote "sv stop FC-1" 2>/dev/null || true
    sleep 1

    echo "Pushing FC-1 binary to target..."
    eval $SCP_CMD "$LOCAL_BINARY" "${TARGET_USER}@${TARGET_HOST}:${REMOTE_BINARY}"

    echo "Setting permissions..."
    run_remote "chmod +x ${REMOTE_BINARY}"

    if [ "$start_service" = true ]; then
        echo "Starting FC-1 service..."
        run_remote "sv start FC-1"
    else
        echo "FC-1 service left stopped (use 'push -run' to auto-start)"
    fi

    echo ""
    echo "Deployed: $LOCAL_BINARY -> $REMOTE_BINARY"
    run_remote "ls -la ${REMOTE_BINARY}"
}

# Push configuration file to target
# Usage: push_config <config_file>
push_config() {
    local config_file="$1"
    local remote_config_dir="/usr/qk/etc/sv/FC-1"

    if [ -z "$config_file" ]; then
        echo "Error: No configuration file specified"
        echo "Usage: $0 config <config_file>"
        exit 1
    fi

    if [ ! -f "$config_file" ]; then
        echo "Error: Configuration file not found: $config_file"
        exit 1
    fi

    local config_basename
    config_basename=$(basename "$config_file")

    echo "Deploying configuration file to target..."
    echo "Source: $config_file"
    echo "Target: ${remote_config_dir}/${config_basename}"

    # Delete any existing .bin files in the config directory
    echo "Removing existing .bin files from ${remote_config_dir}..."
    local bin_files
    bin_files=$(run_remote "ls ${remote_config_dir}/*.bin 2>/dev/null" || true)
    if [ -n "$bin_files" ]; then
        echo "Found .bin files to remove:"
        echo "$bin_files"
        run_remote "rm -f ${remote_config_dir}/*.bin"
        echo "Removed .bin files"
    else
        echo "No .bin files found"
    fi

    # Copy the configuration file
    echo "Copying configuration file..."
    if ! eval $SCP_CMD "$config_file" "${TARGET_USER}@${TARGET_HOST}:${remote_config_dir}/${config_basename}"; then
        echo "Error: Failed to copy configuration file"
        exit 1
    fi

    # Verify the file was copied
    if run_remote "test -f ${remote_config_dir}/${config_basename}"; then
        echo ""
        echo "Configuration deployed successfully:"
        run_remote "ls -la ${remote_config_dir}/${config_basename}"
    else
        echo "Error: Configuration file not found on target after copy"
        exit 1
    fi
}

# Run command on target (uses eval - avoid for commands with special chars)
run_remote() {
    eval $SSH_CMD "$@"
}

# Run command on target safely without eval (preserves special characters like ?)
run_ssh() {
    sshpass -p "${TARGET_PASS}" ssh "${SSH_OPTS[@]}" "${TARGET_USER}@${TARGET_HOST}" "$@"
}

# Run service script on target
run_service_cmd() {
    # Deploy if script doesn't exist on target
    run_remote "test -f ${REMOTE_SCRIPT}" 2>/dev/null || deploy_script
    # Use sh to run script (target /tmp may be noexec)
    run_remote "sh ${REMOTE_SCRIPT} $*"
}

# Deploy expect tools to target
deploy_expect() {
    if [ ! -f "$EXPECT_PACKAGE" ]; then
        echo "Error: Expect package not found at $EXPECT_PACKAGE"
        echo "Run the build_expect.sh script first"
        exit 1
    fi

    echo "Deploying expect tools to target (persistent location)..."
    echo "Package: $EXPECT_PACKAGE"
    echo "Target: ${REMOTE_EXPECT_DIR}"

    # Copy expect package to target with verification
    echo "Copying package to target..."
    if ! eval $SCP_CMD "$EXPECT_PACKAGE" "${TARGET_USER}@${TARGET_HOST}:/tmp/expect-arm.tar.gz"; then
        echo "Error: SCP failed to copy expect package"
        exit 1
    fi

    # Verify the file arrived
    if ! run_remote "test -f /tmp/expect-arm.tar.gz"; then
        echo "Error: Package file not found on target after SCP"
        exit 1
    fi

    # Create directory and extract
    echo "Extracting to ${REMOTE_EXPECT_DIR}..."
    run_remote "mkdir -p ${REMOTE_EXPECT_DIR}"

    if ! run_remote "cd ${REMOTE_EXPECT_DIR} && tar xzf /tmp/expect-arm.tar.gz"; then
        echo "Error: Failed to extract expect package"
        run_remote "rm -f /tmp/expect-arm.tar.gz"
        exit 1
    fi

    # Clean up temp file
    run_remote "rm -f /tmp/expect-arm.tar.gz"

    # Verify deployment
    if run_remote "test -x ${REMOTE_EXPECT_DIR}/bin/expect-wrapper"; then
        echo "Expect tools deployed successfully to ${REMOTE_EXPECT_DIR}"
    else
        echo "Error: expect-wrapper not found after deployment"
        exit 1
    fi
}

# Check if expect is installed on target
check_expect_installed() {
    run_remote "test -x ${REMOTE_EXPECT_DIR}/bin/expect" 2>/dev/null
}

# Execute CLI command via expect/microcom
run_cli_cmd() {
    local cli_cmd="$1"

    if [ -z "$cli_cmd" ]; then
        echo "Error: No command specified"
        echo "Usage: $0 cmd \"<command>\""
        exit 1
    fi

    # Check if expect is installed, deploy if not
    if ! check_expect_installed; then
        echo "Expect not found on target. Deploying..."
        deploy_expect
    fi

    # Copy expect script to target
    if [ ! -f "$EXPECT_CMD_SCRIPT" ]; then
        echo "Error: Expect script not found at $EXPECT_CMD_SCRIPT"
        exit 1
    fi

    eval $SCP_CMD "$EXPECT_CMD_SCRIPT" "${TARGET_USER}@${TARGET_HOST}:${REMOTE_EXPECT_CMD}"
    run_remote "chmod +x ${REMOTE_EXPECT_CMD}"

    # Run the expect script with the command
    # Quote the command argument for remote shell to prevent glob expansion
    echo "Executing: $cli_cmd"
    echo "---"
    run_ssh "${REMOTE_EXPECT_DIR}/bin/expect-wrapper ${REMOTE_EXPECT_CMD} '${cli_cmd}'"
}

##
# @brief Check if OS upgrade is needed by comparing versions
# @return 0 if upgrade needed, 1 if current or error
##
check_os_version() {
    echo "Checking OS version on target..."

    local versions
    versions=$(run_remote "cat /var/ver/versions 2>/dev/null")

    if [ -z "$versions" ]; then
        echo "Warning: Could not read /var/ver/versions"
        return 1
    fi

    # Extract version components
    local uboot_ver kernel_ver squash_ver rootfs_ver
    uboot_ver=$(echo "$versions" | grep "^u-boot=" | cut -d= -f2)
    kernel_ver=$(echo "$versions" | grep "^kernel=" | cut -d= -f2)
    squash_ver=$(echo "$versions" | grep "^squash-fs=" | cut -d= -f2)
    rootfs_ver=$(echo "$versions" | grep "^root-fs=" | cut -d= -f2)

    echo "Current versions:"
    echo "  u-boot:    ${uboot_ver:-unknown}"
    echo "  kernel:    ${kernel_ver:-unknown}"
    echo "  squash-fs: ${squash_ver:-unknown}"
    echo "  root-fs:   ${rootfs_ver:-unknown}"
    echo "  Latest:    ${LATEST_OS_VERSION}"

    # Check if all components are at latest version
    if [ "$uboot_ver" = "$LATEST_OS_VERSION" ] && \
       [ "$kernel_ver" = "$LATEST_OS_VERSION" ] && \
       [ "$squash_ver" = "$LATEST_OS_VERSION" ] && \
       [ "$rootfs_ver" = "$LATEST_OS_VERSION" ]; then
        echo ""
        echo "OS is up to date (${LATEST_OS_VERSION})"
        return 1
    fi

    echo ""
    echo "OS upgrade available: current -> ${LATEST_OS_VERSION}"
    return 0
}

##
# @brief Detect memory model (512MB or 128MB)
# @return 0 on success (sets MEMORY_MODEL), 1 on error
##
detect_memory_model() {
    echo "Detecting memory model..."

    local meminfo
    meminfo=$(run_remote "cat /proc/meminfo 2>/dev/null")

    if [ -z "$meminfo" ]; then
        echo "Error: Could not read /proc/meminfo"
        return 1
    fi

    local mem_total_kb
    mem_total_kb=$(echo "$meminfo" | grep "^MemTotal:" | awk '{print $2}')

    if [ -z "$mem_total_kb" ]; then
        echo "Error: Could not parse MemTotal"
        return 1
    fi

    echo "Detected memory: ${mem_total_kb} kB"

    if [ "$mem_total_kb" -ge "$MEMORY_THRESHOLD_KB" ]; then
        MEMORY_MODEL="512"
        echo "Memory model: 512MB"
    else
        MEMORY_MODEL="128"
        echo "Memory model: 128MB"
    fi

    return 0
}

##
# @brief Run update_universal.sh and check for success
# @param $1 Component type (squash-fs, kernel, u-boot, root-fs)
# @param $2 Archive filename
# @return 0 on success, 1 on failure
# @note update_universal.sh returns non-zero exit codes even on success,
#       so we check for "Finish update artifact" in the output instead
##
run_update_component() {
    local component="$1"
    local archive="$2"
    local output

    output=$(run_remote "/etc/update_universal.sh --yes --type ${component} --save --arch ${archive} --dir ${REMOTE_UPGRADE_DIR}" 2>&1)
    echo "$output"

    # Check for success string in output (script may return non-zero even on success)
    if echo "$output" | grep -q "Finish update artifact"; then
        return 0
    else
        return 1
    fi
}

##
# @brief Perform OS upgrade on target device
# @note Requires MEMORY_MODEL to be set (call detect_memory_model first)
# @return 0 on success, 1 on failure
##
perform_os_upgrade() {
    if [ -z "$MEMORY_MODEL" ]; then
        echo "Error: Memory model not detected"
        return 1
    fi

    local upgrade_src_dir uboot_file
    if [ "$MEMORY_MODEL" = "512" ]; then
        upgrade_src_dir="$UPGRADE_DIR_512MB"
        uboot_file="u-boot-512_4.0.0.zip"
    else
        upgrade_src_dir="$UPGRADE_DIR_128MB"
        uboot_file="u-boot-128_4.0.0.zip"
    fi

    # Verify upgrade files exist
    echo "Verifying upgrade files in ${upgrade_src_dir}..."
    for file in kernel_4.0.0.zip root-fs_4.0.0.zip squash-fs_4.0.0.zip "$uboot_file"; do
        if [ ! -f "${upgrade_src_dir}/${file}" ]; then
            echo "Error: Missing upgrade file: ${file}"
            return 1
        fi
    done
    echo "All upgrade files found."

    # Copy upgrade files to target
    echo ""
    echo "Copying upgrade files to target ${REMOTE_UPGRADE_DIR}..."
    for file in kernel_4.0.0.zip root-fs_4.0.0.zip squash-fs_4.0.0.zip "$uboot_file"; do
        echo "  Copying ${file}..."
        if ! eval $SCP_CMD "${upgrade_src_dir}/${file}" "${TARGET_USER}@${TARGET_HOST}:${REMOTE_UPGRADE_DIR}/"; then
            echo "Error: Failed to copy ${file}"
            return 1
        fi
    done
    echo "All files copied successfully."

    # Execute upgrade commands in order
    echo ""
    echo "Executing OS upgrade sequence..."

    echo "1. Upgrading squash-fs..."
    if ! run_update_component "squash-fs" "squash-fs_4.0.0.zip"; then
        echo "Error: squash-fs upgrade failed"
        return 1
    fi

    echo "2. Upgrading kernel..."
    if ! run_update_component "kernel" "kernel_4.0.0.zip"; then
        echo "Error: kernel upgrade failed"
        return 1
    fi

    echo "3. Upgrading u-boot (${MEMORY_MODEL}MB)..."
    if ! run_update_component "u-boot" "${uboot_file}"; then
        echo "Error: u-boot upgrade failed"
        return 1
    fi

    echo "4. Upgrading root-fs (this will trigger reboot)..."
    if ! run_update_component "root-fs" "root-fs_4.0.0.zip"; then
        echo "Error: root-fs upgrade failed"
        return 1
    fi

    echo ""
    echo "OS upgrade complete. The device will reboot."
    echo "Please wait for the device to come back online, then verify with:"
    echo "  ./fc1 ssh"
    echo "  cat /var/ver/versions"

    return 0
}

##
# @brief Check for OS upgrade and prompt user
# @return 0 to continue, exits on upgrade or abort
##
check_and_prompt_upgrade() {
    if check_os_version; then
        echo ""
        printf "Would you like to upgrade the OS before continuing? [y/N]: "
        read -r response
        case "$response" in
            [yY]|[yY][eE][sS])
                if ! detect_memory_model; then
                    echo "Cannot determine memory model. Skipping upgrade."
                    return 0
                fi
                if perform_os_upgrade; then
                    echo ""
                    echo "Upgrade initiated. Please reconnect after reboot."
                    exit 0
                else
                    echo ""
                    printf "Upgrade failed. Continue with deploy/push anyway? [y/N]: "
                    read -r cont
                    case "$cont" in
                        [yY]|[yY][eE][sS])
                            return 0
                            ;;
                        *)
                            exit 1
                            ;;
                    esac
                fi
                ;;
            *)
                echo "Skipping OS upgrade."
                ;;
        esac
    fi
    return 0
}

show_help() {
    echo "FC-1 Remote Control"
    echo ""
    echo "Usage: $0 [-d destination] <command> [options]"
    echo ""
    echo "Options:"
    echo "  -d <addr>   Specify target host (default: 192.168.7.1)"
    echo ""
    echo "Commands:"
    echo "  start       Start FC-1 service on target"
    echo "  stop        Stop FC-1 service on target"
    echo "  restart     Restart FC-1 service"
    echo "  status      Show service status"
    echo "  enable      Enable FC-1 auto-start and start service"
    echo "  disable     Disable FC-1 auto-start (with confirmation)"
    echo "  disable -y  Disable without confirmation prompt"
    echo "  run [opts]  Run FC-1 in foreground on target"
    echo "  log         Show recent logs"
    echo "  ppp         Show PPP link status (interface, service, log)"
    echo "  cmd <cmd>   Execute CLI command via microcom (returns output)"
    echo "  config <file> Deploy config file to target (removes old .bin files first)"
    echo "  deploy      Deploy service script to target (checks OS version first)"
    echo "  push        Push built FC-1 binary to target (checks OS version first)"
    echo "  push -run   Push binary and start FC-1 service"
    echo "  upgrade     Check and upgrade target OS to ${LATEST_OS_VERSION}"
    echo "  fix-eth0    Fix eth0 IP address if USB ethernet is down"
    echo "  ssh         Open SSH session to target"
    echo "  clear-key   Clear SSH host key (for device changes)"
    echo "  help        Show this help"
    echo ""
    echo "Target: ${TARGET_USER}@${TARGET_HOST}:${TARGET_PORT}"
    echo ""
    echo "Examples:"
    echo "  $0 start                 # Start FC-1 on default host"
    echo "  $0 -d 192.168.1.100 start  # Start FC-1 on specific host"
    echo "  $0 stop                  # Stop FC-1"
    echo "  $0 enable                # Enable auto-start"
    echo "  $0 disable               # Disable auto-start (prompts)"
    echo "  $0 disable -y            # Disable without prompt"
    echo "  $0 status                # Check status"
    echo "  $0 -d 10.0.0.50 status   # Check status on specific host"
    echo "  $0 run -S                # Run with config summary"
    echo "  $0 ppp                   # Show PPP link status"
    echo "  $0 cmd \"help\"            # Execute 'help' CLI command"
    echo "  $0 cmd \"cell status\"     # Execute 'cell status' CLI command"
    echo "  $0 cmd \"imx stats\"       # Execute 'imx stats' CLI command"
    echo "  $0 config myconfig.bin   # Deploy config file to target"
    echo "  $0 deploy                # Update service script on target"
    echo "  $0 push                  # Deploy binary (service stays stopped)"
    echo "  $0 push -run             # Deploy binary and start service"
    echo "  $0 upgrade               # Check and upgrade OS if needed"
    echo "  $0 -d beaglebone.local ssh  # SSH to specific host"
    echo ""
}

# Main
check_sshpass

case "$1" in
    start|stop|restart|status|enable|log|create-run|ppp)
        check_target
        run_service_cmd "$1"
        ;;
    disable)
        check_target
        shift
        run_service_cmd "disable" "$@"
        ;;
    run)
        check_target
        shift
        run_service_cmd "run" "$@"
        ;;
    deploy)
        check_target
        check_and_prompt_upgrade
        deploy_script
        ;;
    push)
        check_target
        check_and_prompt_upgrade
        shift
        push_binary "$@"
        ;;
    upgrade)
        check_target
        if check_os_version; then
            if ! detect_memory_model; then
                echo "Error: Cannot determine memory model"
                exit 1
            fi
            perform_os_upgrade
        else
            echo "No upgrade needed."
        fi
        ;;
    ssh)
        check_target
        echo "Connecting to ${TARGET_HOST}..."
        eval $SSH_CMD
        ;;
    cmd)
        check_target
        shift
        run_cli_cmd "$*"
        ;;
    config)
        check_target
        shift
        push_config "$1"
        ;;
    clear-key)
        clear_host_key
        echo "Host key cleared. Next connection will accept new key."
        ;;
    fix-eth0)
        check_target
        echo "Fixing eth0 on target..."
        run_remote "ip addr flush dev eth0; ip addr add 192.168.7.1/24 dev eth0; ip link set eth0 up"
        echo "Done. Verifying:"
        run_remote "ip addr show eth0 | grep inet"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        if [ -z "$1" ]; then
            # Default: show status
            check_target
            run_service_cmd "status"
        else
            echo "Unknown command: $1"
            echo "Run '$0 help' for usage."
            exit 1
        fi
        ;;
esac

exit 0
