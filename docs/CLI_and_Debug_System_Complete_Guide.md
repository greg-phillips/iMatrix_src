# iMatrix and Fleet-Connect-1 CLI and Debug System Complete Guide

**Document Version:** 1.1
**Last Updated:** 2026-01-02
**Author:** Generated by Claude Code

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [System Overview](#system-overview)
3. [iMatrix CLI System Architecture](#imatrix-cli-system-architecture)
4. [Fleet-Connect-1 CLI System Architecture](#fleet-connect-1-cli-system-architecture)
5. [Debug System Deep Dive](#debug-system-deep-dive)
6. [PRINTF Macro System](#printf-macro-system)
7. [Adding a New CLI Command](#adding-a-new-cli-command)
8. [Processing Subcommands](#processing-subcommands)
9. [Adding a New Debug Command](#adding-a-new-debug-command)
10. [Required Files and Modifications](#required-files-and-modifications)
11. [Required Includes and Variables](#required-includes-and-variables)
12. [Practical Examples](#practical-examples)
13. [Best Practices](#best-practices)
14. [Troubleshooting](#troubleshooting)
15. [Testing and Remote Access](#testing-and-remote-access)

---

## Executive Summary

This document provides a comprehensive guide to the Command Line Interface (CLI) and debug systems used in both **iMatrix** (core library) and **Fleet-Connect-1** (gateway application). It covers:

- How the CLI systems work
- How the debug flag system operates
- How PRINTF macros are used for conditional debugging
- Step-by-step instructions for adding new debug commands
- Complete file dependencies and modification requirements

### Quick Reference

**iMatrix CLI:**
- Entry Point: `iMatrix/cli/cli.c`
- Debug Flags: `iMatrix/cli/messages.h`
- Print Functions: `iMatrix/cli/interface.c`
- Macro Pattern: `#define PRINTF(...) if(LOGS_ENABLED(FLAG)) imx_cli_log_printf(true, __VA_ARGS__)`

**Fleet-Connect-1 CLI:**
- Entry Point: `Fleet-Connect-1/cli/fcgw_cli.c`
- Debug Flags: `Fleet-Connect-1/cli/app_messages.h`
- Macro Pattern: `#define PRINTF(...) if(APP_LOGS_ENABLED(FLAG)) imx_cli_log_printf(true, __VA_ARGS__)`

---

## System Overview

### Two Separate CLI Systems

The iMatrix project contains **two independent CLI systems**:

1. **iMatrix Core CLI**: Built into the iMatrix library, provides system-level commands for memory, networking, CoAP, BLE, storage, etc.

2. **Fleet-Connect-1 Application CLI**: Specific to the Fleet-Connect-1 gateway application, provides commands for CAN bus, OBD2, vehicle monitoring, etc.

### Relationship Between Systems

```
┌─────────────────────────────────────────┐
│     Fleet-Connect-1 Application         │
│                                         │
│  ┌───────────────────────────────────┐  │
│  │  Fleet-Connect CLI (app mode)     │  │
│  │  - CAN commands                   │  │
│  │  - OBD2 commands                  │  │
│  │  - Vehicle-specific commands      │  │
│  └───────────────────────────────────┘  │
│                ↓                        │
│  ┌───────────────────────────────────┐  │
│  │  Registers handler with iMatrix   │  │
│  │  imx_set_cli_handler()            │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────┐
│        iMatrix Core Library             │
│                                         │
│  ┌───────────────────────────────────┐  │
│  │  iMatrix CLI (cli mode)           │  │
│  │  - System commands                │  │
│  │  - Memory, Network, BLE           │  │
│  │  - CoAP, Storage, WiFi            │  │
│  │  - Debug control                  │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

**Mode Switching:**
- Press `TAB` to toggle between CLI mode and APP mode
- CLI mode: iMatrix system commands
- APP mode: Fleet-Connect-1 application commands
- Type `app` in CLI mode to switch to APP mode
- Type `exit` in APP mode to switch back to CLI mode

---

## iMatrix CLI System Architecture

### Core Components

#### 1. Command Dispatcher (`cli.c`)

**Location:** `/home/greg/iMatrix/iMatrix_Client/iMatrix/cli/cli.c`

**Purpose:** Main command processing loop and command table

**Key Structures:**

```c
typedef struct {
    char *command_string;           // Command name (e.g., "debug")
    void (*cli_function)(uint16_t arg);  // Handler function
    uint16_t arg;                   // Argument passed to handler
    char *help_string;              // Help text displayed by '?'
} cli_commands_t;
```

**Command Table Example:**

```c
const cli_commands_t command[] = {
    {"?", &cli_help, 0, "Print this help"},
    {"debug", &cli_debug, 0, "Debug control - 'debug on/off', 'debug <flag>'"},
    {"mem", &cli_memory_status, 0, "Memory status - Display heap usage"},
    {"s", &cli_status, 0, "System status - Display system state"},
    // ... more commands ...
    {NULL, NULL, 0, NULL}  // Terminator
};
```

**Command Processing Flow:**

1. User types command and presses Enter
2. `cli_process_ch()` accumulates characters into command line buffer
3. On Enter, tokenize command using `strtok()`
4. Search command table for matching command string
5. If found, call the registered function pointer with arg
6. If not found, check host CLI handler (for Fleet-Connect-1)

#### 2. Print Interface (`interface.c`)

**Location:** `/home/greg/iMatrix/iMatrix_Client/iMatrix/cli/interface.c`

**Purpose:** Provides output functions for CLI and debug messages

**Key Functions:**

```c
// For general status messages (controlled by AT_verbose and cli_enabled)
void imx_printf(char *format, ...);

// For debug logging with optional timestamps
void imx_cli_log_printf(bool print_time, char *format, ...);

// For CLI output (to active device: console, telnet, BLE UART, TTY)
void imx_cli_print(char *format, ...);

// For direct string output
void imx_cli_print_str(char *str);
```

**Output Device Support:**

```c
typedef enum output_devices {
    CONSOLE_OUTPUT,     // Serial console/terminal
    TELNET_OUTPUT,      // Telnet connection
    BLE_UART_OUTPUT,    // BLE UART service
    TTY_DEVICE_OUTPUT   // TTY device (Linux)
} imx_output_device_t;
```

**Output Routing:**
- All print functions check the `active_device` variable
- Messages are routed to the appropriate output stream
- Thread-safe with mutex protection (`imx_cli_print_mutex`)

**Timestamp Format:**

```c
// Output with timestamp:
[HH:MM:SS.mmm] Your debug message here
[02:45:33.125] Network state changed to CONNECTED

// With RTC enabled (DEBUGS_LOG_RTC):
[HH:MM:SS.mmm] [UTC_HH:MM:SS.mmm] Your message
[02:45:33.125] [10:45:33.125] Network state changed
```

#### 3. Debug Messages (`messages.h`)

**Location:** `/home/greg/iMatrix/iMatrix_Client/iMatrix/cli/messages.h`

**Purpose:** Defines debug flag enumeration and macros

**Debug Flag Enumeration:**

```c
typedef enum {
    DEBUGS_GENERAL = 0,              // Bit 0
    DEBUGS_FOR_XMIT,                 // Bit 1  - CoAP transmit
    DEBUGS_FOR_RECV,                 // Bit 2  - CoAP receive
    DEBUGS_FOR_COAP_DEFINES,         // Bit 3  - CoAP support
    DEBUGS_FOR_IMX_UPLOAD,           // Bit 4  - iMatrix upload
    DEBUGS_FOR_IMX_TSD_UPLOAD,       // Bit 5  - TSD/ESD upload
    DEBUGS_FOR_IMX_UPLOAD_HUMAN,     // Bit 6  - Human readable upload
    DEBUGS_FOR_HAL,                  // Bit 7  - Hardware abstraction
    DEBUGS_FOR_BLE,                  // Bit 8  - BLE client
    DEBUGS_FOR_BASIC_MESSAGING,      // Bit 9  - Basic messaging
    DEBUGS_FOR_SFLASH,               // Bit 10 - Serial flash
    DEBUGS_FOR_APPLICATION_START,    // Bit 11 - Application startup
    DEBUGS_FOR_EVENTS_DRIVEN,        // Bit 12 - Event-driven entries
    DEBUGS_FOR_SAMPLING,             // Bit 13 - Sample-driven entries
    DEBUGS_FOR_MEMORY_MANAGER,       // Bit 14 - Memory manager
    DEBUGS_FOR_TELNET,               // Bit 15 - Telnet daemon
    DEBUGS_FOR_WIFI,                 // Bit 16 - WiFi connections
    DEBUGS_FOR_ETH0_NETWORKING,      // Bit 17 - Ethernet networking
    DEBUGS_FOR_WIFI0_NETWORKING,     // Bit 18 - WiFi networking
    DEBUGS_FOR_PPP0_NETWORKING,      // Bit 19 - PPP networking
    DEBUGS_FOR_NETWORKING_SWITCH,    // Bit 20 - Network switching
    DEBUGS_FOR_WICED_WWD,            // Bit 21 - WICED WWD
    DEBUGS_FOR_CSR,                  // Bit 22 - CSR
    DEBUGS_FOR_BACKGROUND_MSGS,      // Bit 23 - Background messages
    DEBUGS_FOR_GATT_CLIENT,          // Bit 24 - GATT client
    DEBUGS_FOR_HTTP_CLIENT,          // Bit 25 - HTTP client
    DEBUGS_FOR_SN_MAC,               // Bit 26 - Serial/MAC
    DEBUGS_FOR_BTSTACK_DEBUG,        // Bit 27 - BTstack debug
    DEBUGS_FOR_BTSTACK_INFO,         // Bit 28 - BTstack info
    DEBUGS_FOR_BTSTACK_ERROR,        // Bit 29 - BTstack error
    DEBUGS_FOR_DFU,                  // Bit 30 - DFU
    DEBUGS_FOR_BLESRV,               // Bit 31 - BLE server
    DEBUGS_ADD_TSD_EVT,              // Bit 32 - TSD/EVT read/write
    DEBUGS_LOG_RTC,                  // Bit 33 - Add RTC to logs
    DEBUGS_FOR_UDP,                  // Bit 34 - UDP transport
#ifdef CELLULAR_PLATFORM
    DEBUGS_FOR_CELLUAR,              // Bit 35 - Cellular
#endif
#ifdef GPS_PLATFORM
    DEBUGS_FOR_GPS,                  // Bit 36 - GPS
    DEBUGS_FOR_GPS_DATA,             // Bit 37 - GPS data
    DEBUGS_FOR_MOVING,               // Bit 38 - Moving/idle detection
    DEBUGS_FOR_LOCATION_STATE,       // Bit 39 - Location state
    DEBUGS_FOR_GEOFENCE,             // Bit 40 - Geofencing
#endif
#ifdef CAN_PLATFORM
    DEBUGS_FOR_CANBUS,               // Bit 41 - CAN bus
    DEBUGS_FOR_CANBUS_DATA,          // Bit 42 - CAN bus data
    DEBUGS_FOR_CANBUS_SAMPLE,        // Bit 43 - CAN bus sample
    DEBUGS_FOR_CANBUS_EVENT,         // Bit 44 - CAN bus event
    DEBUGS_CAN_REGISTRATION,         // Bit 45 - CAN registration
    DEBUGS_CAN_DECODE_DEBUG,         // Bit 46 - CAN decode debug
    DEBUGS_CAN_DECODE_ERROR,         // Bit 47 - CAN decode errors
#endif
    NO_DEBUG_MSGS                    // Total count
} DEBUGS_LOGS_COMPONENT_T;
```

**Debug Check Macro:**

```c
// Check if a debug flag is enabled
#define LOGS_ENABLED(x) ((device_config.log_messages & ((uint64_t)1<<(uint64_t)x)))

// Enable a specific debug flag
#define ENABLE_LOGS(x)  do { device_config.log_messages |= ((uint64_t)1<<(uint64_t)x); } while (0)

// Disable a specific debug flag
#define DISABLE_LOGS(x) do { device_config.log_messages &= ~((uint64_t)1<<(uint64_t)x); } while (0)
```

**Storage:**

Debug flags are stored in the `device_config` structure as a 64-bit bitmask:

```c
typedef struct {
    // ... other fields ...
    bool print_debugs;          // Master debug enable/disable
    uint64_t log_messages;      // 64-bit bitmask of enabled flags
    // ... other fields ...
} IOT_Device_Config_t;

extern IOT_Device_Config_t device_config;
```

#### 4. Debug Command Handler (`cli_debug.c`)

**Location:** `/home/greg/iMatrix/iMatrix_Client/iMatrix/cli/cli_debug.c`

**Purpose:** Implements the `debug` CLI command for controlling debug output

**Command Syntax:**

```bash
debug on                    # Enable all debug output
debug off                   # Disable all debug output
debug ?                     # List all available debug flags
debug <flag_value>          # Set specific flags (hex or decimal)
debug +<flag_value>         # Add flags to current setting
debug -<flag_value>         # Remove flags from current setting
debug save <filename>       # Redirect debug output to file
debug stop                  # Stop file logging
debug status                # Show current logging destination
```

**Key Implementation Details:**

```c
void cli_debug(uint16_t mode)
{
    bool print_flags;
    char *token;
    uint64_t log_messages;
    uint64_t prev_log_messages;

    token = strtok(NULL, " ");  // Get argument

    if (strcmp(token, "on") == 0) {
        device_config.print_debugs = true;
        imatrix_save_config();
        print_flags = true;
    }
    else if (strcmp(token, "off") == 0) {
        device_config.print_debugs = false;
        imatrix_save_config();
    }
    else if (strcmp(token, "?") == 0) {
        // List all debug flags with descriptions
        for (i = 0; i < NO_DEBUG_MSGS; i++) {
            imx_cli_print("0x%016llx - %s\r\n",
                         (1ULL << i),
                         debug_flags_description[i]);
        }
    }
    else {
        // Parse hex or decimal flag value
        bool add = false, del = false;
        if (*token == '+') { add = true; token++; }
        if (*token == '-') { del = true; token++; }

        if (strncmp(token, "0x", 2) == 0) {
            log_messages = strtoull(&token[2], NULL, 16);
        } else {
            log_messages = strtoull(token, NULL, 10);
        }

        prev_log_messages = device_config.log_messages;
        if (add) {
            device_config.log_messages |= log_messages;
        } else if (del) {
            device_config.log_messages &= ~log_messages;
        } else {
            device_config.log_messages = log_messages;
        }

        if (prev_log_messages != device_config.log_messages) {
            imatrix_save_config();
        }
    }

    // Print current debug flags if requested
    if (print_flags) {
        imx_cli_print("Debug: %s, Current flags: 0x%016llx\r\n",
                     device_config.print_debugs ? "On" : "Off",
                     device_config.log_messages);
        for (i = 0; i < NO_DEBUG_MSGS; i++) {
            if (LOGS_ENABLED(i)) {
                imx_cli_print("0x%016llx - %s\r\n",
                             (1ULL << i),
                             debug_flags_description[i]);
            }
        }
    }
}
```

**Debug Flag Descriptions:**

The `debug_flags_description` array provides human-readable descriptions:

```c
static const char *debug_flags_description[NO_DEBUG_MSGS] = {
    [DEBUGS_GENERAL]                = "General Debugging",
    [DEBUGS_FOR_BASIC_MESSAGING]    = "Debugs For Basic CoAP Messaging",
    [DEBUGS_FOR_XMIT]               = "Debugs For CoAP Xmit",
    [DEBUGS_FOR_RECV]               = "Debugs For CoAP Recv",
    // ... etc ...
};
```

### CLI State Machine

**States:**

```c
enum cli_states {
    CLI_SETUP_CONSOLE,     // Setting up console
    CLI_SETUP_TELNET,      // Setting up telnet
    CLI_SETUP_BLE_UART,    // Setting up BLE UART
    CLI_GET_CMD,           // Getting command input
    CLI_PROCESS_CMD,       // Processing command
#ifdef LINUX_PLATFORM
    CLI_FILE_VIEW,         // Viewing file content
    CLI_FILE_VIEW_SEARCH,  // In search mode
    CLI_MEMORY_MONITOR     // Live memory monitoring
#endif
};
```

**Command History:**

The CLI maintains command history for each input device:

```c
#define COMMAND_HISTORY_SIZE 10

typedef struct {
    char commands[COMMAND_HISTORY_SIZE][COMMAND_LINE_LENGTH];
    uint16_t write_index;    // Where to write next command
    uint16_t current_index;  // Current position in history
    uint16_t count;          // Number of commands stored
} command_history_t;
```

**Arrow Key Support:**

- **Up Arrow** (ESC [ A): Recall previous command
- **Down Arrow** (ESC [ B): Recall next command

---

## Fleet-Connect-1 CLI System Architecture

### Core Components

#### 1. Application CLI Handler (`fcgw_cli.c`)

**Location:** `/home/greg/iMatrix/iMatrix_Client/Fleet-Connect-1/cli/fcgw_cli.c`

**Purpose:** Implements application-specific CLI commands

**Integration with iMatrix CLI:**

```c
void mgw_cli_init(void)
{
    // Register our handler with iMatrix CLI
    imx_set_cli_handler(mgw_cli_handler);
}

bool mgw_cli_handler(char *token)
{
    // Process application-specific commands
    // Return true if command was handled, false otherwise

    if (strcmp(token, "e") == 0) {
        // Energy command
        process_energy_command();
        return true;
    }
    else if (strcmp(token, "trip") == 0) {
        // Trip command
        process_trip_command();
        return true;
    }
    // ... more commands ...

    return false;  // Command not recognized
}
```

#### 2. Application Debug Flags (`app_messages.h`)

**Location:** `/home/greg/iMatrix/iMatrix_Client/Fleet-Connect-1/cli/app_messages.h`

**Purpose:** Defines application-specific debug flags

**Debug Flag Enumeration:**

```c
typedef enum {
    /* General System Debug Types */
    DEBUGS_APP_GENERAL = 0,       // Bit 0  - General app debugging
    DEBUGS_APP_HAL = 1,           // Bit 1  - HAL functions
    DEBUGS_APP_GPIO = 2,          // Bit 2  - GPIO operations
    DEBUGS_APP_POWER = 3,         // Bit 3  - Power management
    DEBUGS_APP_ENERGY_MANAGER = 4,// Bit 4  - Energy manager

    /* CAN Bus Related Debug Types */
    DEBUGS_APP_CAN_CTRL = 5,      // Bit 5  - CAN controller
    DEBUGS_APP_CAN = 6,           // Bit 6  - CAN bus
    DEBUGS_APP_CAN_READ = 7,      // Bit 7  - CAN read operations
    DEBUGS_APP_CAN_DATA = 8,      // Bit 8  - CAN data
    DEBUGS_APP_CAN_UPLOAD = 9,    // Bit 9  - CAN upload
    DEBUGS_APP_MAPPINGS = 10,     // Bit 10 - Signal mappings

    /* OBD2 Related Debug Types */
    DEBUGS_APP_OBD2 = 11,         // Bit 11 - OBD2 protocol
    DEBUGS_APP_OBD2_READ = 12,    // Bit 12 - OBD2 reads
    DEBUGS_APP_PID_READ = 13,     // Bit 13 - PID reads

    /* Data Collection and Upload */
    DEBUGS_APP_SAMPLE = 14,       // Bit 14 - Sampling
    DEBUGS_APP_HOST_UPLOAD = 15,  // Bit 15 - Upload to host
    DEBUGS_APP_REGISTRATION = 16, // Bit 16 - Vehicle registration

    /* Sensor Debug Types */
    DEBUGS_APP_GFORCE = 17,       // Bit 17 - G-force sensor
    DEBUGS_APP_GFORCE_READ = 18,  // Bit 18 - G-force reads

    /* Vehicle Specific */
    DEBUGS_APP_HM_TRUCK = 19,     // Bit 19 - HM Truck
    DEBUGS_APP_CARB = 20,         // Bit 20 - CARB compliance
    DEBUGS_APP_DRIVER_SCORE = 21, // Bit 21 - Driver scoring

    /* EV Abstraction Layer */
    DEBUGS_APP_HM_ADAPTER = 22,   // Bit 22 - HM adapter
    DEBUGS_APP_EV_VAL = 23,       // Bit 23 - EV VAL
    DEBUGS_APP_EV_FACTORY = 24,   // Bit 24 - EV factory
    DEBUGS_APP_APTERA = 25,       // Bit 25 - Aptera vehicle

    NO_DEBUG_APP_MSGS             // Total count
} DEBUGS_APP_LOGS_COMPONENT_T;
```

**Application Debug Macros:**

```c
// Check if application debug flag is enabled
#define APP_LOGS_ENABLED(x) ((mgc.log_messages & (1<<x)))

// Enable application debug flag
#define ENABLE_APP_LOGS(x)  do { mgc.log_messages |= (1<<x); } while (0)

// Disable application debug flag
#define DISABLE_APP_LOGS(x) do { mgc.log_messages &= ~(1<<x); } while (0)
```

**Storage:**

Application debug flags are stored in the `mgc` structure as a 32-bit bitmask:

```c
typedef struct {
    // ... other fields ...
    uint32_t log_messages;      // 32-bit bitmask of enabled flags
    // ... other fields ...
} management_global_control_t;

extern management_global_control_t mgc;
```

---

## Debug System Deep Dive

### How Debug Flags Work

#### Bitmask System

Debug flags use a bitmask approach where each flag corresponds to a single bit position:

```
Bit Position:  63 62 61 ... 3  2  1  0
Flag Value:    2^63 ... ... 8  4  2  1

Example for DEBUGS_FOR_CANBUS (bit 41):
Binary:  0000...0010000000000000000000000000000000000000000
Hex:     0x0000020000000000
Decimal: 2199023255552
```

**Flag Value Calculation:**

```c
// For flag at bit position N:
flag_value = (uint64_t)1 << N

// Examples:
DEBUGS_FOR_CANBUS (bit 41):       (1ULL << 41) = 0x0000020000000000
DEBUGS_FOR_MEMORY_MANAGER (bit 14): (1ULL << 14) = 0x0000000000004000
DEBUGS_FOR_ETH0_NETWORKING (bit 17): (1ULL << 17) = 0x0000000000020000
```

#### Enabling Multiple Flags

**Combine flags using bitwise OR:**

```bash
# Enable CAN bus (bit 41) + Memory manager (bit 14)
debug 0x0000020000004000

# Or in decimal:
debug 2199023259648

# Add flags incrementally:
debug 0x4000              # Enable memory manager
debug +0x20000000000      # Add CAN bus debugging
```

**Common Combinations:**

```bash
# Network debugging (ETH0 + WIFI0 + PPP0):
debug 0xE0000             # Bits 17, 18, 19

# CoAP debugging (XMIT + RECV + DEFINES):
debug 0x1C                # Bits 2, 3, 4

# CAN debugging (all CAN flags):
debug 0x0001FE0000000000  # Bits 41-48
```

### Runtime Debug Control

#### Enabling/Disabling at Runtime

```bash
# Master enable/disable
> debug on                # Enable debug output globally
> debug off               # Disable all debug output

# Specific flag control
> debug 0x4000            # Set only memory manager flag
> debug +0x20000          # Add ETH0 networking flag
> debug -0x20000          # Remove ETH0 networking flag

# List active flags
> debug on                # Shows all enabled flags
```

#### Debug Output Redirection

**File Logging:**

```c
// Implementation in cli_debug.c
bool imx_debug_start_file_logging(const char *filename)
{
    debug_log_file = fopen(filename, "w");
    if (debug_log_file == NULL) {
        return false;
    }

    file_logging_active = true;
    strncpy(current_log_filename, filename, sizeof(current_log_filename) - 1);

    fprintf(debug_log_file, "=== iMatrix Debug Log Started ===\r\n");
    fflush(debug_log_file);

    return true;
}
```

**CLI Usage:**

```bash
# Start logging to file
> debug save mylog.txt
Debug output redirected to: mylog.txt

# Stop file logging
> debug stop
Debug output restored to console

# Check logging status
> debug status
Debug logging to: mylog.txt
```

### Configuration Persistence

**Saving Debug Settings:**

```c
// Debug settings are saved to non-volatile storage
void cli_debug(uint16_t mode)
{
    // ... parse command ...

    // Save configuration if changed
    if (prev_log_messages != device_config.log_messages) {
        imatrix_save_config();  // Persist to flash/file
    }
}
```

**Configuration File (Linux):**

```bash
# Location: /usr/qk/etc/sv/config.bin or config.json
{
    "print_debugs": true,
    "log_messages": "0x0000020000004000"
}
```

---

## PRINTF Macro System

### Standard PRINTF Macro Pattern

The PRINTF macro pattern is used throughout the codebase to provide conditional debug output based on compile-time and runtime flags.

#### Pattern 1: Basic Conditional PRINTF

**Most Common Pattern:**

```c
// In source file (e.g., can_process.c)
#ifdef PRINT_DEBUGS_CANBUS
#undef PRINTF
#define PRINTF(...)                             \
    if (LOGS_ENABLED(DEBUGS_FOR_CANBUS)) {      \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }
#elif !defined PRINTF
#define PRINTF(...)  // No-op if not defined
#endif
```

**Usage in Code:**

```c
void imx_can_process(imx_time_t current_time)
{
    if (cb.cbs.last_state != cb.cbs.state) {
        PRINTF("[CAN BUS System State Change: %s -> %s]\r\n",
               cb_states[cb.cbs.last_state],
               cb_states[cb.cbs.state]);
        cb.cbs.last_state = cb.cbs.state;
    }

    // ... more code with PRINTF() calls ...
}
```

**How It Works:**

1. **Compile-time check:** `#ifdef PRINT_DEBUGS_CANBUS` determines if debug code is included
2. **Runtime check:** `LOGS_ENABLED(DEBUGS_FOR_CANBUS)` checks if flag is enabled
3. **Output:** If both checks pass, `imx_cli_log_printf()` outputs the message with timestamp

#### Pattern 2: Interface-Specific PRINTF

**For Network Interfaces:**

```c
// Define separate macros for each interface
#define PRINTF_ETH0(...)                         \
    if (LOGS_ENABLED(DEBUGS_FOR_ETH0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

#define PRINTF_WIFI0(...)                        \
    if (LOGS_ENABLED(DEBUGS_FOR_WIFI0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

#define PRINTF_PPP0(...)                         \
    if (LOGS_ENABLED(DEBUGS_FOR_PPP0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }
```

**Usage:**

```c
void process_ethernet(void)
{
    PRINTF_ETH0("Ethernet link up, configuring DHCP\r\n");
    // ... ethernet-specific code ...
}

void process_wifi(void)
{
    PRINTF_WIFI0("WiFi connected to SSID: %s\r\n", ssid);
    // ... wifi-specific code ...
}
```

#### Pattern 3: Severity-Level PRINTF

**Different levels of verbosity:**

```c
#define PRINTF_INFO(...)                         \
    if (LOGS_ENABLED(DEBUGS_FOR_MEMORY_MANAGER)) { \
        imx_cli_log_printf(true, "[INFO] " __VA_ARGS__); \
    }

#define PRINTF_WARNING(...)                      \
    if (LOGS_ENABLED(DEBUGS_FOR_MEMORY_MANAGER)) { \
        imx_cli_log_printf(true, "[WARN] " __VA_ARGS__); \
    }

#define PRINTF_ERROR(...)                        \
    imx_cli_log_printf(true, "[ERROR] " __VA_ARGS__)  // Always printed
```

**Usage:**

```c
void memory_manager_allocate(size_t size)
{
    PRINTF_INFO("Allocating %zu bytes\r\n", size);

    if (size > MAX_ALLOCATION) {
        PRINTF_WARNING("Large allocation requested: %zu bytes\r\n", size);
    }

    void *ptr = malloc(size);
    if (ptr == NULL) {
        PRINTF_ERROR("Memory allocation failed for %zu bytes\r\n", size);
        return NULL;
    }

    return ptr;
}
```

### Macro Variants

#### With Timestamp Control

```c
// Print with timestamp (most common)
#define PRINTF(...) \
    if (LOGS_ENABLED(FLAG)) imx_cli_log_printf(true, __VA_ARGS__)

// Print without timestamp
#define PRINTF_NO_TS(...) \
    if (LOGS_ENABLED(FLAG)) imx_cli_log_printf(false, __VA_ARGS__)
```

#### Without Timestamp in Output

```c
// Use imx_cli_print instead of imx_cli_log_printf
#define PRINTF(...) \
    if (LOGS_ENABLED(FLAG)) imx_cli_print(__VA_ARGS__)
```

#### Application-Specific

```c
// For Fleet-Connect-1 application code
#define APP_PRINTF(...)                          \
    if (APP_LOGS_ENABLED(DEBUGS_APP_HM_TRUCK)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }
```

### Examples from Codebase

#### CAN Bus Processing

```c
// File: iMatrix/canbus/can_process.c
#ifdef PRINT_DEBUGS_CANBUS
#undef PRINTF
#define PRINTF(...)                             \
    if (LOGS_ENABLED(DEBUGS_FOR_CANBUS)) {      \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }
#elif !defined PRINTF
#define PRINTF(...)
#endif

// Usage:
PRINTF("[CAN BUS System State Change: %s -> %s]\r\n",
       cb_states[cb.cbs.last_state],
       cb_states[cb.cbs.state]);
```

#### Memory Manager

```c
// File: iMatrix/cs_ctrl/mm2_write.c
#ifdef PRINT_DEBUGS_FOR_MEMORY_MANAGER
#define PRINTF(...)                              \
    if (LOGS_ENABLED(DEBUGS_FOR_MEMORY_MANAGER)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }
#else
#define PRINTF(...)
#endif

// Usage:
PRINTF("Writing %u bytes to sector %u\r\n", bytes, sector_num);
```

#### Network Manager

```c
// File: iMatrix/IMX_Platform/LINUX_Platform/networking/process_network.c
#define PRINTF_ETH0(...)                         \
    if (LOGS_ENABLED(DEBUGS_FOR_ETH0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

// Usage:
PRINTF_ETH0("Interface %s: IP=%s, Mask=%s, Gateway=%s\r\n",
            interface->name, ip_str, mask_str, gw_str);
```

#### BLE Operations

```c
// File: iMatrix/ble/ble_manager/ble_mgr.c
#define PRINTF(...) \
    if (LOGS_ENABLED(DEBUGS_FOR_BLE)) imx_cli_log_printf(true, __VA_ARGS__)

// Usage:
PRINTF("BLE device connected: MAC=%s\r\n", mac_address);
```

### Print Function Selection

**When to use each function:**

```c
// 1. imx_cli_log_printf(bool timestamp, format, ...)
//    - Used by PRINTF macros
//    - Supports timestamps
//    - Respects debug flags
//    - Outputs to active device
PRINTF("Debug message: value=%d\r\n", value);

// 2. imx_cli_print(format, ...)
//    - For CLI command output
//    - No timestamp
//    - Always outputs (unless cli_enabled=false)
//    - Outputs to active device
imx_cli_print("Command result: %s\r\n", result);

// 3. imx_printf(format, ...)
//    - For status messages
//    - Controlled by AT_verbose and print_debugs
//    - No timestamp
//    - Outputs to console
imx_printf("System status: %s\r\n", status);
```

---

## Adding a New CLI Command

This section explains how to add a new command to either the iMatrix CLI or Fleet-Connect-1 CLI system.

### Understanding the Command Table

The CLI uses a command table to map command strings to handler functions.

**Command Table Structure:**

```c
typedef struct {
    char *command_string;           // Command name typed by user
    void (*cli_function)(uint16_t arg);  // Function to call
    uint16_t arg;                   // Argument passed to function
    char *help_string;              // Help text for '?' command
} cli_commands_t;
```

**Example Command Table (iMatrix):**

```c
const cli_commands_t command[] = {
    {"?", &cli_help, 0, "Print this help"},
    {"debug", &cli_debug, 0, "Debug control - 'debug on/off', 'debug <flag>'"},
    {"mem", &cli_memory_status, 0, "Memory status - Display heap usage"},
    {"s", &cli_status, 0, "System status - Display system state"},
    {"reboot", &cli_reboot, 0, "System reboot - 'reboot' (normal restart)"},
    // ... more commands ...
    {NULL, NULL, 0, NULL}  // MUST end with NULL entry
};
```

### Adding a Command to iMatrix CLI

#### Step 1: Implement the Command Handler Function

**File:** Create new file or add to existing (e.g., `iMatrix/cli/cli_mycommand.c`)

```c
/*
 * cli_mycommand.c - My New Command Implementation
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include "imx_platform.h"
#include "interface.h"
#include "cli_mycommand.h"

/******************************************************
 *               Function Definitions
 ******************************************************/

/**
 * @brief Handle the 'mycommand' CLI command
 * @param arg Argument from command table (unused in this example)
 *
 * This function is called when user types 'mycommand' in the CLI.
 * It processes any subcommands or arguments.
 */
void cli_mycommand(uint16_t arg)
{
    UNUSED_PARAMETER(arg);  // Not using the arg parameter

    char *token;

    // Get the next token (first argument after command name)
    token = strtok(NULL, " ");

    if (token == NULL) {
        // No arguments - show status or usage
        imx_cli_print("Usage: mycommand <subcommand> [options]\r\n");
        imx_cli_print("Subcommands:\r\n");
        imx_cli_print("  status  - Show current status\r\n");
        imx_cli_print("  start   - Start the feature\r\n");
        imx_cli_print("  stop    - Stop the feature\r\n");
        imx_cli_print("  config <value> - Configure with value\r\n");
        return;
    }

    // Process subcommands
    if (strcmp(token, "status") == 0) {
        // Show status
        imx_cli_print("Feature status: %s\r\n",
                     is_feature_active() ? "Active" : "Inactive");
    }
    else if (strcmp(token, "start") == 0) {
        // Start the feature
        if (start_feature() == IMX_SUCCESS) {
            imx_cli_print("Feature started successfully\r\n");
        } else {
            imx_cli_print("ERROR: Failed to start feature\r\n");
        }
    }
    else if (strcmp(token, "stop") == 0) {
        // Stop the feature
        stop_feature();
        imx_cli_print("Feature stopped\r\n");
    }
    else if (strcmp(token, "config") == 0) {
        // Get the configuration value
        char *value_str = strtok(NULL, " ");
        if (value_str == NULL) {
            imx_cli_print("ERROR: Missing configuration value\r\n");
            imx_cli_print("Usage: mycommand config <value>\r\n");
            return;
        }

        // Parse the value
        uint32_t value = strtoul(value_str, NULL, 0);  // Auto-detect hex/decimal

        // Apply configuration
        if (configure_feature(value) == IMX_SUCCESS) {
            imx_cli_print("Feature configured with value: %u (0x%X)\r\n",
                         value, value);
        } else {
            imx_cli_print("ERROR: Invalid configuration value\r\n");
        }
    }
    else {
        // Unknown subcommand
        imx_cli_print("ERROR: Unknown subcommand: %s\r\n", token);
        imx_cli_print("Type 'mycommand' for usage information\r\n");
    }
}
```

**Create Header File:**

**File:** `iMatrix/cli/cli_mycommand.h`

```c
/*
 * cli_mycommand.h - My Command Interface
 */

#ifndef CLI_MYCOMMAND_H_
#define CLI_MYCOMMAND_H_

#include <stdint.h>

/**
 * @brief Handle the 'mycommand' CLI command
 * @param arg Argument from command table
 */
void cli_mycommand(uint16_t arg);

#endif /* CLI_MYCOMMAND_H_ */
```

#### Step 2: Add Command to Command Table

**File:** `iMatrix/cli/cli.c`

**Add include at top:**

```c
#include "cli_mycommand.h"  // Add this
```

**Add entry to command table:**

```c
const cli_commands_t command[] = {
    {"?", &cli_help, 0, "Print this help"},
    // ... existing commands ...

    // ADD YOUR COMMAND HERE (maintain alphabetical order):
    {"mycommand", &cli_mycommand, 0, "My feature - 'mycommand status', 'start', 'stop', 'config <value>'"},

    // ... more commands ...
    {NULL, NULL, 0, NULL}  // Keep this last
};
```

**Important Notes:**
- Add command in **alphabetical order** for easy lookup
- Keep help string **concise but informative**
- Use **lowercase** for command names
- End table with **NULL entry**

#### Step 3: Add to Build System

**File:** `iMatrix/CMakeLists.txt`

```cmake
# Add your new source file to the sources list
set(IMATRIX_CLI_SOURCES
    cli/cli.c
    cli/interface.c
    cli/cli_debug.c
    cli/cli_help.c
    cli/cli_mycommand.c        # ADD THIS
    # ... other files ...
)
```

#### Step 4: Test Your Command

```bash
# In CLI mode
> mycommand
Usage: mycommand <subcommand> [options]
Subcommands:
  status  - Show current status
  start   - Start the feature
  stop    - Stop the feature
  config <value> - Configure with value

> mycommand status
Feature status: Inactive

> mycommand start
Feature started successfully

> mycommand status
Feature status: Active

> mycommand config 42
Feature configured with value: 42 (0x2A)

> mycommand stop
Feature stopped
```

### Adding a Command to Fleet-Connect-1 CLI

For Fleet-Connect-1, commands are handled differently through the application CLI handler.

#### Step 1: Implement Command Handler

**File:** `Fleet-Connect-1/cli/fcgw_cli.c`

**Add to the `mgw_cli_handler` function:**

```c
bool mgw_cli_handler(char *token)
{
    // ... existing command handling ...

    // ADD YOUR COMMAND HERE:
    if (strcmp(token, "myapp") == 0) {
        char *subcmd = strtok(NULL, " ");

        if (subcmd == NULL) {
            // No subcommand - show usage
            imx_cli_print("Usage: myapp <subcommand> [options]\r\n");
            imx_cli_print("Subcommands:\r\n");
            imx_cli_print("  info    - Show application info\r\n");
            imx_cli_print("  enable  - Enable feature\r\n");
            imx_cli_print("  disable - Disable feature\r\n");
            return true;
        }

        if (strcmp(subcmd, "info") == 0) {
            imx_cli_print("Application Information:\r\n");
            imx_cli_print("  Version: %s\r\n", APP_VERSION);
            imx_cli_print("  Status:  %s\r\n", get_app_status());
            return true;
        }
        else if (strcmp(subcmd, "enable") == 0) {
            enable_app_feature();
            imx_cli_print("Feature enabled\r\n");
            return true;
        }
        else if (strcmp(subcmd, "disable") == 0) {
            disable_app_feature();
            imx_cli_print("Feature disabled\r\n");
            return true;
        }
        else {
            imx_cli_print("ERROR: Unknown subcommand: %s\r\n", subcmd);
            return true;
        }
    }

    // ... other commands ...

    return false;  // Command not recognized
}
```

**Important:** Return `true` if command was handled, `false` if not recognized.

#### Step 2: Test Your Application Command

```bash
# Switch to APP mode
> app

# Test your command
app> myapp
Usage: myapp <subcommand> [options]
Subcommands:
  info    - Show application info
  enable  - Enable feature
  disable - Disable feature

app> myapp info
Application Information:
  Version: 1.2.3
  Status:  Running

app> myapp enable
Feature enabled
```

### Command Handler Patterns

#### Pattern 1: Simple Command (No Arguments)

```c
void cli_simple_command(uint16_t arg)
{
    UNUSED_PARAMETER(arg);

    // Perform action
    perform_action();

    // Show result
    imx_cli_print("Action completed\r\n");
}
```

#### Pattern 2: Command with Subcommands

```c
void cli_command_with_subs(uint16_t arg)
{
    UNUSED_PARAMETER(arg);
    char *subcmd = strtok(NULL, " ");

    if (subcmd == NULL) {
        show_usage();
        return;
    }

    if (strcmp(subcmd, "sub1") == 0) {
        handle_subcommand1();
    }
    else if (strcmp(subcmd, "sub2") == 0) {
        handle_subcommand2();
    }
    else {
        imx_cli_print("ERROR: Unknown subcommand: %s\r\n", subcmd);
    }
}
```

#### Pattern 3: Command with Required Arguments

```c
void cli_command_with_args(uint16_t arg)
{
    UNUSED_PARAMETER(arg);
    char *arg1 = strtok(NULL, " ");
    char *arg2 = strtok(NULL, " ");

    if (arg1 == NULL || arg2 == NULL) {
        imx_cli_print("Usage: command <arg1> <arg2>\r\n");
        return;
    }

    // Parse arguments
    uint32_t value1 = strtoul(arg1, NULL, 0);
    uint32_t value2 = strtoul(arg2, NULL, 0);

    // Process
    process_values(value1, value2);
}
```

#### Pattern 4: Command with Optional Arguments

```c
void cli_command_optional(uint16_t arg)
{
    UNUSED_PARAMETER(arg);
    char *arg1 = strtok(NULL, " ");

    if (arg1 == NULL) {
        // No arguments - use defaults
        show_status_default();
    } else {
        // Process with argument
        uint32_t filter = strtoul(arg1, NULL, 0);
        show_status_filtered(filter);
    }
}
```

#### Pattern 5: Command with Variable Arguments

```c
void cli_command_varargs(uint16_t arg)
{
    UNUSED_PARAMETER(arg);
    char *token;
    uint32_t values[10];
    uint16_t count = 0;

    // Collect all arguments
    while ((token = strtok(NULL, " ")) != NULL && count < 10) {
        values[count++] = strtoul(token, NULL, 0);
    }

    if (count == 0) {
        imx_cli_print("ERROR: No arguments provided\r\n");
        return;
    }

    // Process all values
    process_array(values, count);
}
```

### Using the 'arg' Parameter

The `arg` parameter can be used to share handlers or pass configuration:

```c
// In command table, use different arg values:
const cli_commands_t command[] = {
    {"show_temp", &cli_show_sensor, SENSOR_TYPE_TEMP, "Show temperature"},
    {"show_humid", &cli_show_sensor, SENSOR_TYPE_HUMID, "Show humidity"},
    {"show_press", &cli_show_sensor, SENSOR_TYPE_PRESS, "Show pressure"},
    // ...
};

// Shared handler uses arg to determine sensor:
void cli_show_sensor(uint16_t sensor_type)
{
    float value = read_sensor(sensor_type);

    switch (sensor_type) {
        case SENSOR_TYPE_TEMP:
            imx_cli_print("Temperature: %.1f °C\r\n", value);
            break;
        case SENSOR_TYPE_HUMID:
            imx_cli_print("Humidity: %.1f %%\r\n", value);
            break;
        case SENSOR_TYPE_PRESS:
            imx_cli_print("Pressure: %.1f hPa\r\n", value);
            break;
    }
}
```

---

## Processing Subcommands

This section explains in detail how subcommands are parsed and processed in CLI command handlers.

### The strtok() Function

The CLI uses `strtok()` to tokenize command strings:

```c
char *strtok(char *str, const char *delim);
```

**Key Points:**
- First call: pass the string to tokenize
- Subsequent calls: pass `NULL` to continue tokenizing same string
- Returns pointer to next token or `NULL` if no more tokens
- **MODIFIES** the original string (inserts `\0` terminators)

### Command Line Parsing Flow

```
User types: "mycommand start option1 option2"
                ↓
CLI accumulates into buffer: "mycommand start option1 option2"
                ↓
CLI calls: token = strtok(buffer, " ")
                ↓
token → "mycommand"
                ↓
CLI looks up "mycommand" in command table
                ↓
CLI calls: cli_mycommand(arg)
                ↓
Inside handler, buffer state:
"mycommand\0start option1 option2"
            ↑
         Current position
                ↓
Handler calls: token = strtok(NULL, " ")
                ↓
token → "start"
```

### Basic Subcommand Processing

**Pattern:**

```c
void cli_command(uint16_t arg)
{
    UNUSED_PARAMETER(arg);

    // Get first subcommand (or argument)
    char *subcmd = strtok(NULL, " ");

    if (subcmd == NULL) {
        // No subcommand provided
        show_usage();
        return;
    }

    // Process subcommand
    if (strcmp(subcmd, "subcommand1") == 0) {
        handle_subcommand1();
    }
    else if (strcmp(subcmd, "subcommand2") == 0) {
        handle_subcommand2();
    }
    else {
        imx_cli_print("ERROR: Unknown subcommand: %s\r\n", subcmd);
    }
}
```

### Multi-Level Subcommands

For complex commands with nested subcommands:

```c
void cli_network(uint16_t arg)
{
    UNUSED_PARAMETER(arg);
    char *subcmd = strtok(NULL, " ");

    if (subcmd == NULL) {
        show_network_status();
        return;
    }

    // First level subcommands
    if (strcmp(subcmd, "interface") == 0) {
        // Get second level subcommand
        char *iface_cmd = strtok(NULL, " ");

        if (iface_cmd == NULL) {
            list_interfaces();
            return;
        }

        // Second level subcommands
        if (strcmp(iface_cmd, "enable") == 0) {
            char *iface_name = strtok(NULL, " ");
            if (iface_name == NULL) {
                imx_cli_print("Usage: network interface enable <name>\r\n");
                return;
            }
            enable_interface(iface_name);
        }
        else if (strcmp(iface_cmd, "disable") == 0) {
            char *iface_name = strtok(NULL, " ");
            if (iface_name == NULL) {
                imx_cli_print("Usage: network interface disable <name>\r\n");
                return;
            }
            disable_interface(iface_name);
        }
        else {
            imx_cli_print("ERROR: Unknown interface command: %s\r\n", iface_cmd);
        }
    }
    else if (strcmp(subcmd, "route") == 0) {
        // Handle route subcommands
        handle_route_commands();
    }
    else {
        imx_cli_print("ERROR: Unknown network command: %s\r\n", subcmd);
    }
}
```

### Collecting Multiple Arguments

```c
void cli_config_set(uint16_t arg)
{
    UNUSED_PARAMETER(arg);

    // Get parameter name
    char *param = strtok(NULL, " ");
    if (param == NULL) {
        imx_cli_print("Usage: config_set <parameter> <value>\r\n");
        return;
    }

    // Get value
    char *value_str = strtok(NULL, " ");
    if (value_str == NULL) {
        imx_cli_print("ERROR: Missing value for parameter: %s\r\n", param);
        return;
    }

    // Get optional third argument
    char *option = strtok(NULL, " ");

    // Parse value
    uint32_t value = strtoul(value_str, NULL, 0);

    // Set configuration
    set_config(param, value, option);
}
```

### Real-World Example: Debug Command

**From:** `iMatrix/cli/cli_debug.c`

```c
void cli_debug(uint16_t mode)
{
    UNUSED_PARAMETER(mode);

    bool print_flags = false;
    char *token;

    // Get first argument
    token = strtok(NULL, " ");

    if (token == NULL) {
        imx_cli_print("Invalid option, debug <on|off|?|flags>\r\n");
        return;
    }

    // Process subcommands
    if (strcmp(token, "on") == 0) {
        device_config.print_debugs = true;
        imatrix_save_config();
        print_flags = true;
    }
    else if (strcmp(token, "off") == 0) {
        device_config.print_debugs = false;
        imatrix_save_config();
    }
    else if (strcmp(token, "save") == 0) {
        // Get filename argument
        char *filename = strtok(NULL, " ");
        if (filename == NULL) {
            filename = "imx_log.txt";
        }

        if (imx_debug_start_file_logging(filename)) {
            imx_cli_print("Debug output redirected to: %s\r\n", filename);
        } else {
            imx_cli_print("ERROR: Failed to start file logging\r\n");
        }
    }
    else if (strcmp(token, "stop") == 0) {
        if (file_logging_active) {
            imx_debug_stop_file_logging();
            imx_cli_print("Debug output restored to console\r\n");
        } else {
            imx_cli_print("File logging not active\r\n");
        }
    }
    else if (strcmp(token, "?") == 0) {
        // List all debug flags
        for (uint16_t i = 0; i < NO_DEBUG_MSGS; i++) {
            imx_cli_print("0x%016llx - %s\r\n",
                         (1ULL << i),
                         debug_flags_description[i]);
        }
        print_flags = true;
    }
    else {
        // Assume it's a flag value
        bool add = false, del = false;

        // Check for +/- prefix
        if (*token == '+') {
            add = true;
            token++;
        } else if (*token == '-') {
            del = true;
            token++;
        }

        // Parse hex or decimal
        uint64_t log_messages;
        if (strncmp(token, "0x", 2) == 0) {
            log_messages = strtoull(&token[2], NULL, 16);
        } else {
            log_messages = strtoull(token, NULL, 10);
        }

        // Apply flags
        if (add) {
            device_config.log_messages |= log_messages;
        } else if (del) {
            device_config.log_messages &= ~log_messages;
        } else {
            device_config.log_messages = log_messages;
        }

        imatrix_save_config();
    }

    if (print_flags) {
        imx_cli_print("Debug: %s, Flags: 0x%016llx\r\n",
                     device_config.print_debugs ? "On" : "Off",
                     device_config.log_messages);
        // Print enabled flags...
    }
}
```

### Real-World Example: Network Command

**From:** `iMatrix/cli/cli.c` and `iMatrix/IMX_Platform/LINUX_Platform/cli/cli_net_wrapper.c`

```c
// In cli.c - wrapper function
static void cli_net(uint16_t arg)
{
    char *token;
    char *argv[10];
    uint16_t argc = 0;

    (void)arg;

    // First token is command name itself
    argv[argc++] = "net";

    // Collect all remaining tokens
    token = strtok(NULL, " ");
    while (token != NULL && argc < 10) {
        argv[argc++] = token;
        token = strtok(NULL, " ");
    }

    // Call net wrapper with argc/argv style
    extern void cli_net_wrapper(uint16_t argc, char *argv[]);
    cli_net_wrapper(argc, argv);
}

// In cli_net_wrapper.c - actual handler
void cli_net_wrapper(uint16_t argc, char *argv[])
{
    if (argc < 2) {
        // No subcommand - show status
        show_network_status();
        return;
    }

    char *subcmd = argv[1];

    if (strcmp(subcmd, "mode") == 0) {
        if (argc < 3) {
            // Show current mode
            show_network_mode();
        } else {
            // Set mode with remaining args
            set_network_mode(argc - 2, &argv[2]);
        }
    }
    else if (strcmp(subcmd, "cell") == 0) {
        handle_cellular_commands(argc - 2, &argv[2]);
    }
    else if (strcmp(subcmd, "status") == 0) {
        show_network_status();
    }
    else {
        imx_cli_print("ERROR: Unknown net command: %s\r\n", subcmd);
    }
}
```

### Real-World Example: CAN Command

**From:** `iMatrix/cli/cli_canbus.c`

```c
void cli_canbus(uint16_t arg)
{
    UNUSED_PARAMETER(arg);
    char *token;

    token = strtok(NULL, " ");

    if (token == NULL) {
        // No arguments - show status
        imx_display_canbus_status(0);
        return;
    }

    // Process subcommands
    if (strcmp(token, "all") == 0) {
        // Show detailed status
        imx_display_canbus_status(1);
    }
    else if (strcmp(token, "sim") == 0) {
        // Simulation mode
        char *mode = strtok(NULL, " ");
        if (mode == NULL) {
            imx_cli_print("Usage: can sim <on|off>\r\n");
            return;
        }

        if (strcmp(mode, "on") == 0) {
            enable_can_simulation();
            imx_cli_print("CAN simulation enabled\r\n");
        } else if (strcmp(mode, "off") == 0) {
            disable_can_simulation();
            imx_cli_print("CAN simulation disabled\r\n");
        }
    }
    else if (strcmp(token, "send") == 0) {
        // Send CAN message
        char *id_str = strtok(NULL, " ");
        char *data_str = strtok(NULL, " ");

        if (id_str == NULL || data_str == NULL) {
            imx_cli_print("Usage: can send <id> <data>\r\n");
            return;
        }

        uint32_t id = strtoul(id_str, NULL, 0);
        uint64_t data = strtoull(data_str, NULL, 0);

        send_can_message(id, data);
    }
    else if (strcmp(token, "nodes") == 0) {
        // Show detected nodes
        display_can_nodes();
    }
    else if (strcmp(token, "unknown") == 0) {
        // Show unknown CAN IDs
        display_unknown_can_ids();
    }
    else {
        imx_cli_print("ERROR: Unknown CAN command: %s\r\n", token);
        imx_cli_print("Type 'can' for usage\r\n");
    }
}
```

### Parsing Number Arguments

**Common patterns for parsing numerical arguments:**

```c
// Parse as auto-detected (hex if 0x prefix, decimal otherwise)
uint32_t value = strtoul(token, NULL, 0);

// Parse explicitly as hex
uint32_t hex_value = strtoul(token, NULL, 16);

// Parse explicitly as decimal
uint32_t dec_value = strtoul(token, NULL, 10);

// Parse 64-bit value
uint64_t big_value = strtoull(token, NULL, 0);

// Parse with error checking
char *endptr;
uint32_t value = strtoul(token, &endptr, 0);
if (*endptr != '\0') {
    imx_cli_print("ERROR: Invalid number: %s\r\n", token);
    return;
}
```

### Parsing String Arguments

```c
void cli_command_string(uint16_t arg)
{
    UNUSED_PARAMETER(arg);

    char *name = strtok(NULL, " ");
    if (name == NULL) {
        imx_cli_print("ERROR: Name required\r\n");
        return;
    }

    // String is available in 'name' until next strtok() call
    // If you need to preserve it, copy it:
    char name_copy[64];
    strncpy(name_copy, name, sizeof(name_copy) - 1);
    name_copy[sizeof(name_copy) - 1] = '\0';

    // Continue processing
    char *value = strtok(NULL, " ");
    // ...
}
```

### Variable Length Argument Lists

```c
void cli_command_varargs(uint16_t arg)
{
    UNUSED_PARAMETER(arg);

    char *token;
    char *args[10];
    uint16_t count = 0;

    // Collect all arguments
    while ((token = strtok(NULL, " ")) != NULL) {
        if (count >= 10) {
            imx_cli_print("ERROR: Too many arguments (max 10)\r\n");
            return;
        }
        args[count++] = token;
    }

    // Process collected arguments
    for (uint16_t i = 0; i < count; i++) {
        imx_cli_print("Arg %u: %s\r\n", i, args[i]);
    }
}
```

### Best Practices for Subcommand Processing

1. **Always check for NULL:**
   ```c
   char *token = strtok(NULL, " ");
   if (token == NULL) {
       // Handle missing argument
       show_usage();
       return;
   }
   ```

2. **Provide helpful error messages:**
   ```c
   if (strcmp(token, "unknown") != 0) {
       imx_cli_print("ERROR: Unknown subcommand: %s\r\n", token);
       imx_cli_print("Type 'command' for usage\r\n");
       return;
   }
   ```

3. **Show usage when no arguments:**
   ```c
   if (token == NULL) {
       imx_cli_print("Usage: command <subcommand> [options]\r\n");
       imx_cli_print("Subcommands:\r\n");
       imx_cli_print("  sub1 - Description\r\n");
       imx_cli_print("  sub2 - Description\r\n");
       return;
   }
   ```

4. **Use strcmp for exact matches:**
   ```c
   if (strcmp(token, "start") == 0) {
       // Exact match
   }
   ```

5. **Use strncmp for prefix matching:**
   ```c
   if (strncmp(token, "0x", 2) == 0) {
       // Starts with "0x"
   }
   ```

6. **Copy strings if needed after next strtok():**
   ```c
   char *name = strtok(NULL, " ");
   char name_copy[64];
   strncpy(name_copy, name, sizeof(name_copy) - 1);

   // Now safe to call strtok() again
   char *value = strtok(NULL, " ");
   ```

---

## Adding a New Debug Command

This section provides step-by-step instructions for adding a new debug capability to either the iMatrix core or Fleet-Connect-1 application.

### Option 1: Adding to iMatrix Core

#### Step 1: Add Debug Flag to Enumeration

**File:** `iMatrix/cli/messages.h`

**Location:** Add before `NO_DEBUG_MSGS` in enum

```c
typedef enum {
    // ... existing flags ...
    DEBUGS_FOR_UDP,                  // Bit 34
#ifdef CELLULAR_PLATFORM
    DEBUGS_FOR_CELLUAR,              // Bit 35
#endif
#ifdef GPS_PLATFORM
    DEBUGS_FOR_GPS,                  // Bit 36
    // ... more GPS flags ...
#endif
#ifdef CAN_PLATFORM
    DEBUGS_FOR_CANBUS,               // Bit 41
    // ... more CAN flags ...
#endif
    // ADD YOUR NEW FLAG HERE:
    DEBUGS_FOR_MY_NEW_FEATURE,       // Bit 48 (or next available)

    NO_DEBUG_MSGS                    // Keep this last!
} DEBUGS_LOGS_COMPONENT_T;
```

**Important Notes:**
- Add your flag **before** `NO_DEBUG_MSGS`
- Use the next available bit number
- Add descriptive comment with bit number
- Consider platform-specific `#ifdef` guards if needed

#### Step 2: Add Description to Debug Command

**File:** `iMatrix/cli/cli_debug.c`

**Location:** `debug_flags_description` array

```c
static const char *debug_flags_description[NO_DEBUG_MSGS] = {
    [DEBUGS_GENERAL]                = "General Debugging",
    [DEBUGS_FOR_BASIC_MESSAGING]    = "Debugs For Basic CoAP Messaging",
    // ... existing descriptions ...
    [DEBUGS_FOR_CANBUS]             = "Debugs for CAN Bus",
    // ADD YOUR DESCRIPTION HERE:
    [DEBUGS_FOR_MY_NEW_FEATURE]     = "Debugs for My New Feature",
};
```

**Description Guidelines:**
- Keep descriptions concise but clear
- Follow the pattern "Debugs for [Feature Name]"
- Use the same index as in the enum (array indexing)

#### Step 3: Add PRINTF Macro to Your Source File

**File:** Your source file (e.g., `iMatrix/myfeature/my_feature.c`)

**Location:** After includes, before first function

```c
#include <stdint.h>
#include <stdbool.h>
#include "imx_platform.h"
#include "storage.h"
#include "../cli/messages.h"       // REQUIRED for LOGS_ENABLED
#include "../device/config.h"       // REQUIRED for device_config

/******************************************************
 *                      Macros
 ******************************************************/
#ifdef PRINT_DEBUGS_MY_FEATURE      // Compile-time flag
#undef PRINTF
#define PRINTF(...)                             \
    if (LOGS_ENABLED(DEBUGS_FOR_MY_NEW_FEATURE)) { \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }
#elif !defined PRINTF
#define PRINTF(...)  // No-op if not enabled
#endif

/******************************************************
 *               Function Definitions
 ******************************************************/
void my_feature_init(void)
{
    PRINTF("My feature initialized\r\n");
}

void my_feature_process(uint32_t value)
{
    PRINTF("Processing value: %u\r\n", value);
}
```

**Macro Options:**

```c
// Option 1: With timestamp (recommended)
#define PRINTF(...) \
    if (LOGS_ENABLED(DEBUGS_FOR_MY_NEW_FEATURE)) { \
        imx_cli_log_printf(true, __VA_ARGS__); \
    }

// Option 2: Without timestamp
#define PRINTF(...) \
    if (LOGS_ENABLED(DEBUGS_FOR_MY_NEW_FEATURE)) { \
        imx_cli_log_printf(false, __VA_ARGS__); \
    }

// Option 3: Using imx_cli_print (no timestamp)
#define PRINTF(...) \
    if (LOGS_ENABLED(DEBUGS_FOR_MY_NEW_FEATURE)) { \
        imx_cli_print(__VA_ARGS__); \
    }
```

#### Step 4: Add Compile-Time Flag (Optional)

**File:** `CMakeLists.txt` or build configuration

**Option A:** Add to CMake definitions

```cmake
# In your CMakeLists.txt
add_definitions(-DPRINT_DEBUGS_MY_FEATURE)
```

**Option B:** Add to source file

```c
// At top of source file before includes
#define PRINT_DEBUGS_MY_FEATURE
```

**Option C:** Make it configurable

```cmake
# In CMakeLists.txt
option(ENABLE_MY_FEATURE_DEBUG "Enable my feature debugging" OFF)
if(ENABLE_MY_FEATURE_DEBUG)
    add_definitions(-DPRINT_DEBUGS_MY_FEATURE)
endif()
```

#### Step 5: Use PRINTF in Your Code

**Basic Usage:**

```c
void my_feature_process(uint32_t value)
{
    PRINTF("Processing value: %u\r\n", value);

    if (value > MAX_VALUE) {
        PRINTF("WARNING: Value exceeds maximum: %u > %u\r\n",
               value, MAX_VALUE);
    }

    PRINTF("Processing complete\r\n");
}
```

**Advanced Usage with State:**

```c
void my_feature_state_change(state_t old_state, state_t new_state)
{
    PRINTF("[State Change: %s -> %s]\r\n",
           state_names[old_state],
           state_names[new_state]);
}
```

**Data Dump:**

```c
void my_feature_dump_buffer(uint8_t *buffer, size_t len)
{
    PRINTF("Buffer dump (%zu bytes):\r\n", len);
    for (size_t i = 0; i < len; i++) {
        PRINTF("  [%3zu] = 0x%02X\r\n", i, buffer[i]);
    }
}
```

#### Step 6: Test Your Debug Output

**Runtime Testing:**

```bash
# Enable your debug flag
> debug ?                           # List all flags with your new one
> debug 0x1000000000000            # Set your flag (adjust bit position)
> debug +0x1000000000000           # Add to existing flags

# Test your feature
> myfeature_command                # Trigger your code

# Expected output:
[00:01:23.456] Processing value: 42
[00:01:23.457] Processing complete

# Disable debug
> debug -0x1000000000000           # Remove your flag
```

### Option 2: Adding to Fleet-Connect-1 Application

#### Step 1: Add Application Debug Flag

**File:** `Fleet-Connect-1/cli/app_messages.h`

```c
typedef enum {
    /* General System Debug Types */
    DEBUGS_APP_GENERAL = 0,
    // ... existing flags ...

    /* Vehicle Specific */
    DEBUGS_APP_HM_TRUCK = 19,
    DEBUGS_APP_CARB = 20,
    // ADD YOUR NEW FLAG HERE:
    DEBUGS_APP_MY_APP_FEATURE = 26,  // Next available bit

    NO_DEBUG_APP_MSGS
} DEBUGS_APP_LOGS_COMPONENT_T;
```

#### Step 2: Add PRINTF Macro to Application Code

**File:** Your application source file

```c
#include "app_messages.h"           // REQUIRED for APP_LOGS_ENABLED

/******************************************************
 *                      Macros
 ******************************************************/
#ifdef PRINT_DEBUGS_MY_APP_FEATURE
#define PRINTF(...)                          \
    if (APP_LOGS_ENABLED(DEBUGS_APP_MY_APP_FEATURE)) { \
        imx_cli_log_printf(true, __VA_ARGS__); \
    }
#else
#define PRINTF(...)
#endif

/******************************************************
 *               Function Definitions
 ******************************************************/
void my_app_feature_init(void)
{
    PRINTF("Application feature initialized\r\n");
}
```

**Note:** Application debug flags use:
- `APP_LOGS_ENABLED(flag)` instead of `LOGS_ENABLED(flag)`
- Stored in `mgc.log_messages` (32-bit) instead of `device_config.log_messages` (64-bit)

#### Step 3: Add CLI Command for Application Debug

**File:** `Fleet-Connect-1/cli/fcgw_cli.c`

```c
bool mgw_cli_handler(char *token)
{
    // ... existing command handling ...

    if (strcmp(token, "app_debug") == 0) {
        // Get next token for subcommand
        char *subcmd = strtok(NULL, " ");
        if (subcmd == NULL) {
            // Show current application debug flags
            imx_cli_print("Application debug flags: 0x%08x\r\n",
                         mgc.log_messages);
            return true;
        }

        if (strcmp(subcmd, "list") == 0) {
            // List all application debug flags
            imx_cli_print("Application Debug Flags:\r\n");
            imx_cli_print("  0x%08x - DEBUGS_APP_GENERAL\r\n", (1 << DEBUGS_APP_GENERAL));
            imx_cli_print("  0x%08x - DEBUGS_APP_HAL\r\n", (1 << DEBUGS_APP_HAL));
            // ... list all flags ...
            imx_cli_print("  0x%08x - DEBUGS_APP_MY_APP_FEATURE\r\n",
                         (1 << DEBUGS_APP_MY_APP_FEATURE));
            return true;
        }

        if (strcmp(subcmd, "on") == 0) {
            // Enable all application debugging
            mgc.log_messages = 0xFFFFFFFF;
            imx_cli_print("Application debugging enabled\r\n");
            return true;
        }

        if (strcmp(subcmd, "off") == 0) {
            // Disable all application debugging
            mgc.log_messages = 0;
            imx_cli_print("Application debugging disabled\r\n");
            return true;
        }

        // Set specific flags
        uint32_t flags = strtoul(subcmd, NULL, 0);  // Auto-detect hex/decimal
        mgc.log_messages = flags;
        imx_cli_print("Application debug flags set to: 0x%08x\r\n", flags);
        return true;
    }

    return false;
}
```

#### Step 4: Use in Application Code

```c
void my_app_feature_process(void)
{
    PRINTF("Application feature processing started\r\n");

    // Your application code here

    PRINTF("Application feature processing complete\r\n");
}
```

#### Step 5: Test Application Debug

```bash
# Switch to app mode
> app

# Enable app debug
app> app_debug on
Application debugging enabled

# Set specific flags
app> app_debug 0x04000000        # Enable your feature flag
Application debug flags set to: 0x04000000

# Test your feature
app> my_feature_command

# Expected output:
[00:01:23.456] Application feature processing started
[00:01:23.457] Application feature processing complete
```

---

## Required Files and Modifications

This section provides a complete checklist of all files that need to be modified when adding a new debug capability.

### For iMatrix Core Debug Addition

#### Minimum Required Files (3)

1. **iMatrix/cli/messages.h**
   - Add enum entry for your debug flag
   - **Why:** Defines the bit position for your flag

2. **iMatrix/cli/cli_debug.c**
   - Add description in `debug_flags_description` array
   - **Why:** Provides human-readable description for `debug ?` command

3. **Your source file (e.g., iMatrix/myfeature/my_feature.c)**
   - Add PRINTF macro definition
   - Add required includes
   - Use PRINTF() in code
   - **Why:** Implements the debug output

#### Optional Files (for compile-time control)

4. **CMakeLists.txt** (or equivalent build file)
   - Add `-DPRINT_DEBUGS_MY_FEATURE` definition
   - **Why:** Enables compile-time control of debug code

### For Fleet-Connect-1 Application Debug Addition

#### Minimum Required Files (2)

1. **Fleet-Connect-1/cli/app_messages.h**
   - Add enum entry for your application debug flag
   - **Why:** Defines the bit position for your application flag

2. **Your application source file**
   - Add PRINTF macro using `APP_LOGS_ENABLED`
   - Add required includes
   - Use PRINTF() in code
   - **Why:** Implements the debug output

#### Optional Files (for CLI control)

3. **Fleet-Connect-1/cli/fcgw_cli.c**
   - Add CLI command handler for application debug control
   - **Why:** Provides runtime control of application debug flags

### File Dependencies Diagram

```
For iMatrix Core Debug:

messages.h ────────────> Defines DEBUGS_FOR_MY_FEATURE enum
    │
    └──> cli_debug.c ──> Adds description for "debug ?" command
    │
    └──> my_feature.c ─> Uses LOGS_ENABLED(DEBUGS_FOR_MY_FEATURE)
             │
             └──> Includes messages.h and config.h
             └──> Uses imx_cli_log_printf() from interface.c

For Fleet-Connect-1 Application Debug:

app_messages.h ────────> Defines DEBUGS_APP_MY_FEATURE enum
    │
    └──> my_app.c ──────> Uses APP_LOGS_ENABLED(DEBUGS_APP_MY_FEATURE)
             │
             └──> Includes app_messages.h
             └──> Uses imx_cli_log_printf() from iMatrix interface.c
    │
    └──> fcgw_cli.c ───> Optional: CLI command for app debug control
```

### Critical Dependencies

#### For PRINTF Macros to Work:

```c
// Required includes in your source file:
#include "../cli/messages.h"       // For LOGS_ENABLED macro
#include "../device/config.h"       // For device_config structure
#include "imx_platform.h"           // Platform definitions
#include "storage.h"                // May be needed for some configs
```

**External Dependencies:**

```c
// These must be available (from interface.c):
extern IOT_Device_Config_t device_config;
void imx_cli_log_printf(bool print_time, char *format, ...);
```

#### For Application PRINTF Macros:

```c
// Required includes in your application source file:
#include "app_messages.h"           // For APP_LOGS_ENABLED macro
#include "../cli/fcgw_cli.h"        // For mgc structure access

// These must be available:
extern management_global_control_t mgc;
void imx_cli_log_printf(bool print_time, char *format, ...);
```

---

## Required Includes and Variables

This section provides complete templates for setting up debug support in your source files.

### Template for iMatrix Core Source File

```c
/*
 * my_feature.c - My New Feature Implementation
 */

/******************************************************
 *                     Includes
 ******************************************************/
// Standard C library includes
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

// Platform includes
#include "imx_platform.h"

// Core iMatrix includes
#include "storage.h"
#include "../device/config.h"       // REQUIRED for device_config
#include "../cli/messages.h"        // REQUIRED for LOGS_ENABLED

// Your feature-specific includes
#include "my_feature.h"

/******************************************************
 *                      Macros
 ******************************************************/
#ifdef PRINT_DEBUGS_MY_FEATURE
#undef PRINTF
#define PRINTF(...)                             \
    if (LOGS_ENABLED(DEBUGS_FOR_MY_FEATURE)) {  \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }
#elif !defined PRINTF
#define PRINTF(...)
#endif

/******************************************************
 *               Variable Definitions
 ******************************************************/
// External variables (if needed)
extern IOT_Device_Config_t device_config;  // For debug flags

// Your module variables
static bool my_feature_initialized = false;

/******************************************************
 *               Function Definitions
 ******************************************************/
void my_feature_init(void)
{
    PRINTF("My feature initializing...\r\n");

    // Your initialization code

    my_feature_initialized = true;
    PRINTF("My feature initialization complete\r\n");
}
```

### Template for Fleet-Connect-1 Application Source File

```c
/*
 * my_app_feature.c - My Application Feature
 */

/******************************************************
 *                     Includes
 ******************************************************/
// Standard C library includes
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

// iMatrix includes
#include "imx_platform.h"
#include "imatrix.h"

// Application includes
#include "../cli/app_messages.h"    // REQUIRED for APP_LOGS_ENABLED
#include "../cli/fcgw_cli.h"        // For mgc structure
#include "my_app_feature.h"

/******************************************************
 *                      Macros
 ******************************************************/
#ifdef PRINT_DEBUGS_MY_APP_FEATURE
#define PRINTF(...)                                  \
    if (APP_LOGS_ENABLED(DEBUGS_APP_MY_FEATURE)) {   \
        imx_cli_log_printf(true, __VA_ARGS__);       \
    }
#else
#define PRINTF(...)
#endif

/******************************************************
 *               Variable Definitions
 ******************************************************/
// External variables (if needed)
extern management_global_control_t mgc;  // For app debug flags

// Your module variables
static bool my_app_feature_active = false;

/******************************************************
 *               Function Definitions
 ******************************************************/
void my_app_feature_start(void)
{
    PRINTF("Starting application feature\r\n");

    // Your application code

    my_app_feature_active = true;
    PRINTF("Application feature started\r\n");
}
```

### Header File Template

```c
/*
 * my_feature.h - My Feature Interface
 */

#ifndef MY_FEATURE_H_
#define MY_FEATURE_H_

#include <stdint.h>
#include <stdbool.h>

/******************************************************
 *                    Constants
 ******************************************************/
#define MY_FEATURE_MAX_VALUE  1000

/******************************************************
 *                 Type Definitions
 ******************************************************/
typedef enum {
    MY_FEATURE_STATE_IDLE,
    MY_FEATURE_STATE_ACTIVE,
    MY_FEATURE_STATE_ERROR
} my_feature_state_t;

/******************************************************
 *               Function Declarations
 ******************************************************/
void my_feature_init(void);
void my_feature_process(uint32_t value);
my_feature_state_t my_feature_get_state(void);

#endif /* MY_FEATURE_H_ */
```

---

## Practical Examples

This section provides real-world examples from the codebase.

### Example 1: CAN Bus Processing

**Files Modified:**

1. `iMatrix/cli/messages.h` - Added DEBUGS_FOR_CANBUS
2. `iMatrix/cli/cli_debug.c` - Added description
3. `iMatrix/canbus/can_process.c` - Implemented PRINTF macro

**Implementation:**

```c
// File: iMatrix/cli/messages.h (excerpt)
#ifdef CAN_PLATFORM
    DEBUGS_FOR_CANBUS,              // Bit 41
    DEBUGS_FOR_CANBUS_DATA,         // Bit 42
    DEBUGS_FOR_CANBUS_SAMPLE,       // Bit 43
    DEBUGS_FOR_CANBUS_EVENT,        // Bit 44
    DEBUGS_CAN_REGISTRATION,        // Bit 45
    DEBUGS_CAN_DECODE_DEBUG,        // Bit 46
    DEBUGS_CAN_DECODE_ERROR,        // Bit 47
#endif
```

```c
// File: iMatrix/cli/cli_debug.c (excerpt)
static const char *debug_flags_description[NO_DEBUG_MSGS] = {
    // ... other descriptions ...
#ifdef CAN_PLATFORM
    [DEBUGS_FOR_CANBUS]          = "Debugs for CAN Bus",
    [DEBUGS_FOR_CANBUS_DATA]     = "Debugs for CAN Bus Data",
    [DEBUGS_FOR_CANBUS_SAMPLE]   = "Debugs for CAN Bus Sample",
    [DEBUGS_FOR_CANBUS_EVENT]    = "Debugs for CAN Bus Event",
    [DEBUGS_CAN_REGISTRATION]    = "Debugs for CAN Registration",
    [DEBUGS_CAN_DECODE_DEBUG]    = "Debugs for CAN Decode",
    [DEBUGS_CAN_DECODE_ERROR]    = "Debugs for CAN Decode Errors",
#endif
};
```

```c
// File: iMatrix/canbus/can_process.c (excerpt)
#include <stdint.h>
#include <stdbool.h>
#include "imx_platform.h"
#include "storage.h"
#include "../cli/messages.h"
#include "../device/config.h"

#ifdef PRINT_DEBUGS_CANBUS
#undef PRINTF
#define PRINTF(...)                             \
    if (LOGS_ENABLED(DEBUGS_FOR_CANBUS)) {      \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }
#elif !defined PRINTF
#define PRINTF(...)
#endif

void imx_can_process(imx_time_t current_time)
{
    if (cb.cbs.last_state != cb.cbs.state) {
        PRINTF("[CAN BUS System State Change: %s -> %s]\r\n",
               cb_states[cb.cbs.last_state],
               cb_states[cb.cbs.state]);
        cb.cbs.last_state = cb.cbs.state;
    }

    // ... process CAN messages ...
}
```

**Usage:**

```bash
# Enable CAN bus debugging
> debug 0x0000020000000000
Debug flags set to: 0x0000020000000000

# Or use decimal
> debug 2199023255552

# Add to existing flags
> debug +0x0000020000000000

# Expected output when CAN state changes:
[00:12:34.567] [CAN BUS System State Change: CBS_INIT -> CBS_SETUP_CAN_BUS]
[00:12:35.123] [CAN BUS System State Change: CBS_SETUP_CAN_BUS -> CBS_SETUP_CAN_SERVER]
```

### Example 2: Network Manager with Interface-Specific Debugging

**File:** `iMatrix/IMX_Platform/LINUX_Platform/networking/process_network.c`

**Implementation:**

```c
#include "../../../cli/messages.h"
#include "../../../device/config.h"

/******************************************************
 *                      Macros
 ******************************************************/
// General network debugging
#define PRINTF_SWITCH(...)                          \
    if (LOGS_ENABLED(DEBUGS_FOR_NETWORKING_SWITCH)) { \
        imx_cli_log_printf(true, __VA_ARGS__);      \
    }

// Interface-specific debugging
#define PRINTF_ETH0(...)                         \
    if (LOGS_ENABLED(DEBUGS_FOR_ETH0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

#define PRINTF_WIFI0(...)                        \
    if (LOGS_ENABLED(DEBUGS_FOR_WIFI0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

#define PRINTF_PPP0(...)                         \
    if (LOGS_ENABLED(DEBUGS_FOR_PPP0_NETWORKING)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

/******************************************************
 *               Function Definitions
 ******************************************************/
void process_ethernet_interface(void)
{
    PRINTF_ETH0("Ethernet interface: checking link status\r\n");

    if (link_up) {
        PRINTF_ETH0("Ethernet link UP, starting DHCP\r\n");
        start_dhcp_client("eth0");
    } else {
        PRINTF_ETH0("Ethernet link DOWN\r\n");
    }
}

void network_state_machine(void)
{
    PRINTF_SWITCH("Network state: %s -> %s\r\n",
                  state_names[old_state],
                  state_names[new_state]);

    // ... state machine logic ...
}
```

**Usage:**

```bash
# Enable only Ethernet debugging
> debug 0x20000
[00:15:23.456] Ethernet interface: checking link status
[00:15:23.457] Ethernet link UP, starting DHCP

# Enable all network interface debugging
> debug 0xE0000   # Bits 17, 18, 19
[00:15:30.123] Ethernet link UP, starting DHCP
[00:15:31.456] WiFi connected to SSID: MyNetwork
[00:15:32.789] PPP connection established

# Enable network switching logic
> debug 0x100000  # Bit 20
[00:15:40.111] Network state: IDLE -> DISCOVERING
[00:15:41.222] Network state: DISCOVERING -> CONNECTING
```

### Example 3: Memory Manager with Multiple Debug Levels

**File:** `iMatrix/cs_ctrl/mm2_disk_spooling.c`

**Implementation:**

```c
#include "../cli/messages.h"
#include "../device/config.h"

/******************************************************
 *                      Macros
 ******************************************************/
#define PRINTF(...)                              \
    if (LOGS_ENABLED(DEBUGS_FOR_MEMORY_MANAGER)) { \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

// Additional severity levels
#define LOG_SPOOL_INFO(fmt, ...)    PRINTF("[SPOOL-INFO] " fmt "\r\n", ##__VA_ARGS__)
#define LOG_SPOOL_WARNING(fmt, ...) PRINTF("[SPOOL-WARN] " fmt "\r\n", ##__VA_ARGS__)
#define LOG_SPOOL_ERROR(fmt, ...)   PRINTF("[SPOOL-ERROR] " fmt "\r\n", ##__VA_ARGS__)

/******************************************************
 *               Function Definitions
 ******************************************************/
void spool_to_disk(uint8_t *data, size_t length)
{
    LOG_SPOOL_INFO("Spooling %zu bytes to disk", length);

    if (length > MAX_SPOOL_SIZE) {
        LOG_SPOOL_WARNING("Spool size exceeds maximum: %zu > %zu",
                         length, MAX_SPOOL_SIZE);
    }

    int result = write_to_disk(data, length);
    if (result < 0) {
        LOG_SPOOL_ERROR("Disk write failed: error code %d", result);
        return;
    }

    LOG_SPOOL_INFO("Successfully spooled %zu bytes", length);
}
```

**Output:**

```
[00:20:15.123] [SPOOL-INFO] Spooling 4096 bytes to disk
[00:20:15.234] [SPOOL-INFO] Successfully spooled 4096 bytes
[00:20:16.456] [SPOOL-WARNING] Spool size exceeds maximum: 8192 > 4096
[00:20:17.789] [SPOOL-ERROR] Disk write failed: error code -5
```

### Example 4: GPS with Data-Specific Debugging

**File:** `iMatrix/location/get_location.c`

**Implementation:**

```c
#ifdef GPS_PLATFORM

#include "../cli/messages.h"
#include "../device/config.h"

/******************************************************
 *                      Macros
 ******************************************************/
// General GPS debugging
#define PRINTF(...)                      \
    if (LOGS_ENABLED(DEBUGS_FOR_GPS)) {  \
        imx_cli_log_printf(true, __VA_ARGS__); \
    }

// GPS data debugging (more verbose)
#define PRINTF_DATA(...)                      \
    if (LOGS_ENABLED(DEBUGS_FOR_GPS_DATA)) {  \
        imx_cli_log_printf(true, __VA_ARGS__); \
    }

/******************************************************
 *               Function Definitions
 ******************************************************/
void process_gps_data(gps_data_t *gps)
{
    PRINTF("GPS fix acquired: lat=%.6f, lon=%.6f\r\n",
           gps->latitude, gps->longitude);

    PRINTF_DATA("GPS Data:\r\n");
    PRINTF_DATA("  Latitude:  %.6f\r\n", gps->latitude);
    PRINTF_DATA("  Longitude: %.6f\r\n", gps->longitude);
    PRINTF_DATA("  Altitude:  %.2f m\r\n", gps->altitude);
    PRINTF_DATA("  Speed:     %.2f km/h\r\n", gps->speed);
    PRINTF_DATA("  Heading:   %.1f degrees\r\n", gps->heading);
    PRINTF_DATA("  Satellites: %u\r\n", gps->satellites);
    PRINTF_DATA("  HDOP:      %.2f\r\n", gps->hdop);
}

#endif // GPS_PLATFORM
```

**Usage:**

```bash
# Enable basic GPS debugging
> debug 0x0000001000000000  # Bit 36
[00:25:10.123] GPS fix acquired: lat=37.774929, lon=-122.419418

# Enable detailed GPS data
> debug 0x0000003000000000  # Bits 36 and 37
[00:25:15.456] GPS fix acquired: lat=37.774929, lon=-122.419418
[00:25:15.457] GPS Data:
[00:25:15.457]   Latitude:  37.774929
[00:25:15.458]   Longitude: -122.419418
[00:25:15.458]   Altitude:  15.50 m
[00:25:15.459]   Speed:     45.30 km/h
[00:25:15.459]   Heading:   127.5 degrees
[00:25:15.460]   Satellites: 12
[00:25:15.460]   HDOP:      1.20
```

---

## Best Practices

### 1. Debug Flag Naming Conventions

**Use Descriptive Names:**

```c
// Good:
DEBUGS_FOR_CANBUS
DEBUGS_FOR_ETH0_NETWORKING
DEBUGS_FOR_MEMORY_MANAGER

// Bad:
DEBUGS_CAN
DEBUGS_NET
DEBUGS_MEM
```

**Follow Patterns:**

- For subsystem debugging: `DEBUGS_FOR_[SUBSYSTEM]`
- For specific data: `DEBUGS_FOR_[SUBSYSTEM]_DATA`
- For operations: `DEBUGS_FOR_[SUBSYSTEM]_[OPERATION]`

### 2. PRINTF Macro Patterns

**Always Use Runtime Check:**

```c
// Good:
#define PRINTF(...)                             \
    if (LOGS_ENABLED(DEBUGS_FOR_MY_FEATURE)) {  \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }

// Bad (always prints):
#define PRINTF(...) imx_cli_log_printf(true, __VA_ARGS__)
```

**Use Compile-Time Guards:**

```c
// Good:
#ifdef PRINT_DEBUGS_MY_FEATURE
#define PRINTF(...) /* active definition */
#else
#define PRINTF(...) /* no-op */
#endif

// This allows complete removal of debug code at compile time
```

### 3. Debug Message Formatting

**Include Context:**

```c
// Good:
PRINTF("[CAN] State change: %s -> %s\r\n", old_state, new_state);
PRINTF("[ETH0] Link status: %s\r\n", link_up ? "UP" : "DOWN");

// Bad:
PRINTF("State: %s\r\n", state);
PRINTF("Link: %d\r\n", link);
```

**Use Consistent Prefixes:**

```c
// Subsystem prefix
PRINTF("[CAN] Message received\r\n");
PRINTF("[NET] Interface up\r\n");

// Severity prefix
PRINTF("[INFO] Normal operation\r\n");
PRINTF("[WARN] High temperature\r\n");
PRINTF("[ERROR] Failed to allocate\r\n");
```

### 4. Performance Considerations

**Minimize String Operations:**

```c
// Good (string operations only if debug enabled):
#define PRINTF(...)                             \
    if (LOGS_ENABLED(FLAG)) {                   \
        imx_cli_log_printf(true, __VA_ARGS__);  \
    }

// Bad (always performs sprintf):
char msg[256];
sprintf(msg, "Value: %d", value);
PRINTF("%s\r\n", msg);

// Better:
PRINTF("Value: %d\r\n", value);
```

**Use Compile-Time Elimination:**

```c
// Enables complete removal of debug code
#ifdef PRINT_DEBUGS_MY_FEATURE
#define PRINTF(...) /* code */
#else
#define PRINTF(...) /* nothing - zero overhead */
#endif
```

### 5. Debug Granularity

**Create Multiple Levels:**

```c
// Coarse level (general feature)
#define PRINTF_FEATURE(...)                      \
    if (LOGS_ENABLED(DEBUGS_FOR_FEATURE)) {      \
        imx_cli_log_printf(true, __VA_ARGS__);   \
    }

// Fine level (detailed data)
#define PRINTF_FEATURE_DATA(...)                      \
    if (LOGS_ENABLED(DEBUGS_FOR_FEATURE_DATA)) {      \
        imx_cli_log_printf(true, __VA_ARGS__);        \
    }

// Usage:
PRINTF_FEATURE("Processing started\r\n");
PRINTF_FEATURE_DATA("Input data: %02X %02X %02X\r\n", d[0], d[1], d[2]);
```

### 6. Error vs Debug Messages

**Errors Should Always Print:**

```c
// Error messages (always displayed)
imx_cli_print("[ERROR] Critical failure: %s\r\n", error_msg);

// Debug messages (conditional)
PRINTF("[DEBUG] Processing value: %u\r\n", value);
```

**Use Appropriate Function:**

```c
// For errors (always output):
imx_cli_print() or imx_printf()

// For debug (conditional):
PRINTF() macros with LOGS_ENABLED()
```

### 7. Thread Safety

**Protect Multi-Line Output:**

```c
// Good (atomic output):
void dump_structure(struct_t *s)
{
    PRINTF("Structure dump:\r\n"
           "  field1: %u\r\n"
           "  field2: %u\r\n"
           "  field3: %s\r\n",
           s->field1, s->field2, s->field3);
}

// Bad (can be interrupted):
void dump_structure(struct_t *s)
{
    PRINTF("Structure dump:\r\n");
    PRINTF("  field1: %u\r\n", s->field1);
    PRINTF("  field2: %u\r\n", s->field2);
    PRINTF("  field3: %s\r\n", s->field3);
}
```

### 8. Documentation

**Document Your Debug Flag:**

```c
// In your header file:
/**
 * @brief Process my feature
 * @param value Input value to process
 *
 * Debug output controlled by DEBUGS_FOR_MY_FEATURE flag.
 * Enable with: debug 0x1000000000000
 */
void my_feature_process(uint32_t value);
```

**Comment PRINTF Macros:**

```c
/******************************************************
 *                      Macros
 ******************************************************/
/**
 * PRINTF - Debug output for my feature
 *
 * Controlled by DEBUGS_FOR_MY_FEATURE flag (bit 48)
 * Compile-time enabled with PRINT_DEBUGS_MY_FEATURE
 * Runtime enabled with: debug 0x1000000000000
 */
#ifdef PRINT_DEBUGS_MY_FEATURE
#define PRINTF(...) /* definition */
#endif
```

---

## Troubleshooting

### Common Issues and Solutions

#### Issue 1: PRINTF Not Producing Output

**Symptoms:**
- PRINTF() calls in code don't produce any output
- Other CLI commands work fine

**Checklist:**

1. **Check master debug enable:**
   ```bash
   > debug on
   ```

2. **Check specific flag is enabled:**
   ```bash
   > debug ?
   # Look for your flag in the list
   # Note the hex value

   > debug 0x<your_flag_value>
   ```

3. **Verify compile-time flag:**
   ```c
   // In your source file, check if defined:
   #ifdef PRINT_DEBUGS_MY_FEATURE
   #warning "Debug compilation enabled"  // Should see during build
   #endif
   ```

4. **Check LOGS_ENABLED macro:**
   ```c
   // Add temporary debug:
   #define PRINTF(...)                             \
       do {                                        \
           printf("CHECK: flag=%d\n",              \
                  LOGS_ENABLED(DEBUGS_FOR_MY_FEATURE)); \
           if (LOGS_ENABLED(DEBUGS_FOR_MY_FEATURE)) { \
               imx_cli_log_printf(true, __VA_ARGS__); \
           }                                       \
       } while(0)
   ```

5. **Verify device_config access:**
   ```c
   // In your function, add:
   printf("device_config.log_messages = 0x%016llx\n",
          device_config.log_messages);
   printf("device_config.print_debugs = %d\n",
          device_config.print_debugs);
   ```

#### Issue 2: Compilation Errors

**Error:** `LOGS_ENABLED` undeclared

```c
error: implicit declaration of function 'LOGS_ENABLED'
```

**Solution:** Add required includes:

```c
#include "../cli/messages.h"      // Defines LOGS_ENABLED macro
#include "../device/config.h"      // Defines device_config structure
```

**Error:** `device_config` undeclared

```c
error: 'device_config' undeclared (first use in this function)
```

**Solution:** Add extern declaration or include:

```c
#include "../device/config.h"
extern IOT_Device_Config_t device_config;
```

**Error:** `imx_cli_log_printf` undeclared

```c
error: implicit declaration of function 'imx_cli_log_printf'
```

**Solution:** Verify interface.h is included (usually via storage.h):

```c
#include "storage.h"  // Includes interface.h
```

#### Issue 3: Wrong Debug Flag Bit Position

**Symptoms:**
- Enabling your flag enables other debug output
- Multiple debug sources activate together

**Cause:** Bit position collision

**Solution:**

1. **Verify enum order:**
   ```c
   // In messages.h
   typedef enum {
       // ...
       DEBUGS_FOR_EXISTING_FEATURE,  // Bit N
       DEBUGS_FOR_MY_NEW_FEATURE,    // Should be bit N+1
       // ...
   } DEBUGS_LOGS_COMPONENT_T;
   ```

2. **Check flag value:**
   ```bash
   > debug ?
   # Verify your flag has unique bit position
   # Check hex value doesn't overlap
   ```

3. **Test isolation:**
   ```bash
   # Clear all flags
   > debug 0

   # Set only your flag
   > debug 0x<your_flag_only>

   # Verify only your debug output appears
   ```

#### Issue 4: Debug Output Goes to Wrong Device

**Symptoms:**
- Debug appears on console when using telnet
- Debug missing when expected

**Cause:** Output device routing

**Solution:**

**Check active device:**

```c
// In your PRINTF macro, add temporary check:
#define PRINTF(...)                             \
    do {                                        \
        extern uint16_t active_device;          \
        printf("DEBUG: active_device=%d\n", active_device); \
        if (LOGS_ENABLED(FLAG)) {               \
            imx_cli_log_printf(true, __VA_ARGS__); \
        }                                       \
    } while(0)
```

**Force output to console:**

```c
// Temporary workaround for debugging:
#define PRINTF(...)                             \
    if (LOGS_ENABLED(FLAG)) {                   \
        printf(__VA_ARGS__);  /* Direct to console */ \
        fflush(stdout);                         \
    }
```

#### Issue 5: Timestamps Not Appearing

**Symptoms:**
- Debug messages appear without timestamps
- Expected: `[HH:MM:SS.mmm] message`
- Actual: `message`

**Cause:** Using `imx_cli_print()` instead of `imx_cli_log_printf()`

**Solution:**

```c
// Wrong (no timestamp):
#define PRINTF(...)                             \
    if (LOGS_ENABLED(FLAG)) {                   \
        imx_cli_print(__VA_ARGS__);  /* No timestamp */ \
    }

// Correct (with timestamp):
#define PRINTF(...)                             \
    if (LOGS_ENABLED(FLAG)) {                   \
        imx_cli_log_printf(true, __VA_ARGS__);  /* true = timestamp */ \
    }
```

#### Issue 6: File Logging Not Working

**Symptoms:**
- `debug save mylog.txt` doesn't create file
- Output still goes to console

**Checklist:**

1. **Check file permissions:**
   ```bash
   $ ls -l
   # Verify write permissions in current directory
   ```

2. **Check absolute path:**
   ```bash
   > debug save /tmp/mylog.txt
   # Use full path to avoid ambiguity
   ```

3. **Verify file logging status:**
   ```bash
   > debug status
   Debug logging to: mylog.txt
   ```

4. **Check file creation:**
   ```bash
   $ ls -l mylog.txt
   # Should exist and be growing

   $ tail -f mylog.txt
   # Watch in real-time
   ```

#### Issue 7: Debug Flags Not Persisting

**Symptoms:**
- Debug flags reset after reboot
- Settings lost between sessions

**Cause:** Configuration not being saved

**Solution:**

```c
// Verify imatrix_save_config() is called
void cli_debug(uint16_t mode)
{
    // ... set flags ...

    // Must call to persist:
    imatrix_save_config();
}
```

**Check configuration file:**

```bash
# Linux platform
$ cat /usr/qk/etc/sv/config.json
# Should show your log_messages value

# Or binary config
$ hexdump -C /usr/qk/etc/sv/config.bin
```

---

## Testing and Remote Access

This section describes how to connect to the FC-1 application's CLI for testing and debugging on the QConnect gateway device.

### Gateway Connection Details

| Parameter | Value |
|-----------|-------|
| IP Address | `192.168.7.1` |
| SSH Port | `22222` (non-standard) |
| Username | `root` |
| Password | `PasswordQConnect` |
| Telnet Port | `23` (CLI direct access) |
| Console Symlink | `/usr/qk/etc/sv/FC-1/console` |

**Important**: The SSH port is `22222`, not the standard port 22.

### Method 1: Using the fc1 Helper Script (Recommended)

The `scripts/fc1` script provides the easiest way to interact with the FC-1 CLI remotely from the development host.

#### Installation Prerequisites

```bash
# Install sshpass (required)
sudo apt-get install sshpass
```

#### Basic Usage

```bash
cd /home/greg/iMatrix/iMatrix_Client/scripts

# Execute CLI commands remotely
./fc1 cmd "help"              # Show CLI help
./fc1 cmd "?"                 # Full command list
./fc1 cmd "v"                 # Version info
./fc1 cmd "debug ?"           # List debug flags
./fc1 cmd "debug on"          # Enable all debug output
./fc1 cmd "debug 0x1234"      # Set specific debug flags
./fc1 cmd "cell status"       # Cellular status
./fc1 cmd "imx stats"         # iMatrix statistics
./fc1 cmd "ms"                # Memory statistics

# Service control
./fc1 start                   # Start FC-1 service
./fc1 stop                    # Stop FC-1 service
./fc1 restart                 # Restart FC-1 service
./fc1 status                  # Check service status

# Logs and monitoring
./fc1 log                     # View recent logs
./fc1 ppp                     # PPP link status

# Deployment
./fc1 push                    # Deploy binary (stays stopped)
./fc1 push -run               # Deploy and start service
./fc1 config myconfig.bin     # Deploy config file

# SSH access
./fc1 ssh                     # Interactive SSH session
./fc1 -d 10.0.0.50 cmd "v"    # Use different host
```

#### Debug Testing Workflow

```bash
# 1. Check current debug state
./fc1 cmd "debug ?"           # List all available flags

# 2. Enable specific debug flags
./fc1 cmd "debug +0x100"      # Add a flag
./fc1 cmd "debug -0x100"      # Remove a flag
./fc1 cmd "debug 0x1FF"       # Set exact value

# 3. Monitor output
./fc1 log                     # View logs with debug output

# 4. Disable when done
./fc1 cmd "debug off"         # Turn off all debug
```

### Method 2: Telnet Direct Connection

FC-1 runs a telnet server on port 23 providing direct CLI access without SSH.

#### Interactive Session

```bash
# Using telnet
telnet 192.168.7.1 23

# Using netcat
nc 192.168.7.1 23
```

Once connected, press Enter to see the `>` prompt:

```
$ nc 192.168.7.1 23
IoT Device Command Line Processor
> help
...command list...
> debug ?
...debug flags...
> quit
```

#### Scripted Commands

```bash
# Send a single command
echo "cell status" | nc 192.168.7.1 23

# Send multiple commands
echo -e "debug ?\ncell status\nppp" | nc 192.168.7.1 23

# Capture output to file
echo "imx stats" | nc 192.168.7.1 23 > output.txt
```

### Method 3: SSH + microcom Console

For interactive sessions with full control, SSH to the gateway and use microcom.

#### Step-by-Step

```bash
# 1. SSH to gateway
ssh -p 22222 root@192.168.7.1
# Password: PasswordQConnect

# 2. Verify FC-1 is running
sv status FC-1

# 3. Connect to CLI via console symlink
microcom /usr/qk/etc/sv/FC-1/console

# 4. Press Enter to see prompt, then type commands
> debug ?
> cell status
> help

# 5. Exit microcom: Press Ctrl+X
```

**Note**: The console symlink at `/usr/qk/etc/sv/FC-1/console` always points to the current PTY device.

### Method 4: Using sshpass for Scripting

For automated testing scripts:

```bash
# Single command
sshpass -p 'PasswordQConnect' ssh -p 22222 root@192.168.7.1 "sv status FC-1"

# Copy files
sshpass -p 'PasswordQConnect' scp -P 22222 myfile root@192.168.7.1:/tmp/
```

### Testing Debug Flags

#### View Available Flags

```bash
# Using fc1 script
./fc1 cmd "debug ?"

# Via telnet
echo "debug ?" | nc 192.168.7.1 23
```

Output shows all available debug flags with their bit values:

```
Debug Flags:
  0x0001 - DEBUGS_CELLULAR    : Cellular modem operations
  0x0002 - DEBUGS_CAN         : CAN bus processing
  0x0004 - DEBUGS_NETWORK     : Network manager
  0x0008 - DEBUGS_IMATRIX     : iMatrix upload
  ...
```

#### Enable/Disable Flags

```bash
# Enable all
./fc1 cmd "debug on"

# Disable all
./fc1 cmd "debug off"

# Set specific flag combination
./fc1 cmd "debug 0x0007"      # Cellular + CAN + Network

# Add flag to current value
./fc1 cmd "debug +0x0010"

# Remove flag
./fc1 cmd "debug -0x0002"
```

### Viewing Logs

#### Via fc1 Script

```bash
./fc1 log                     # Recent service logs
```

#### Via SSH

```bash
# Service logs (runit)
tail -f /var/log/FC-1/current

# Application log (with rotation)
tail -f /var/log/fc-1.log

# PPP logs
tail -f /var/log/pppd/current
```

### Common Test Scenarios

#### Debug a Specific Subsystem

```bash
# Enable cellular debug
./fc1 cmd "debug +0x0001"

# Trigger activity
./fc1 cmd "cell scan"

# Watch output
./fc1 log

# Disable when done
./fc1 cmd "debug -0x0001"
```

#### Test CLI Command Output

```bash
# Capture command output
./fc1 cmd "imx stats" > stats_before.txt

# Make changes / run tests

./fc1 cmd "imx stats" > stats_after.txt

# Compare
diff stats_before.txt stats_after.txt
```

#### Monitor in Real-Time

```bash
# Terminal 1: Watch logs
./fc1 ssh
tail -f /var/log/FC-1/current

# Terminal 2: Send commands
./fc1 cmd "debug on"
./fc1 cmd "cell status"
```

### Troubleshooting Access Issues

#### Cannot Reach Gateway

```bash
# Check network connectivity
ping 192.168.7.1

# Check if SSH port is open
nc -zv 192.168.7.1 22222
```

#### SSH Host Key Changed

```bash
# Clear stale key
./fc1 clear-key

# Or manually
ssh-keygen -f "$HOME/.ssh/known_hosts" -R "[192.168.7.1]:22222"
```

#### microcom Lock File Error

If you see `microcom: can't create '/var/lock/LCK..console': File exists`:

```bash
# Check for stale process
./fc1 ssh
cat /var/lock/LCK..console
ps aux | grep microcom

# Kill stale process or remove lock
kill <PID>
# or
rm /var/lock/LCK..console
```

#### Telnet Connection Refused

```bash
# Check if FC-1 is running
./fc1 status

# Start if needed
./fc1 start

# Wait a moment for telnet server to initialize
sleep 2
nc 192.168.7.1 23
```

### Related Documentation

| Document | Description |
|----------|-------------|
| [fc1_script_reference.md](fc1_script_reference.md) | Complete fc1 script reference |
| [testing_fc_1_application.md](testing_fc_1_application.md) | Comprehensive testing guide |
| [validating_FC-1_application.md](validating_FC-1_application.md) | Quick validation reference |
| [expect_tool_use.md](expect_tool_use.md) | Expect tools for remote CLI |

---

## Summary

This document has covered:

1. **Architecture** of both iMatrix and Fleet-Connect-1 CLI systems
2. **Debug flag system** using 64-bit (iMatrix) and 32-bit (Fleet-Connect-1) bitmasks
3. **PRINTF macro patterns** for conditional debug output
4. **Step-by-step instructions** for adding new debug capabilities
5. **Complete file dependencies** and required modifications
6. **Practical examples** from the real codebase
7. **Best practices** for debug implementation
8. **Troubleshooting guide** for common issues
9. **Testing and remote access** methods for connecting to FC-1 CLI on gateway devices

### Quick Reference for Adding Debug Support

**For iMatrix Core:**
1. Add enum to `iMatrix/cli/messages.h`
2. Add description to `iMatrix/cli/cli_debug.c`
3. Add PRINTF macro to your source file
4. Use `LOGS_ENABLED(flag)` in macro
5. Include `messages.h` and `config.h`

**For Fleet-Connect-1:**
1. Add enum to `Fleet-Connect-1/cli/app_messages.h`
2. Add PRINTF macro to your source file
3. Use `APP_LOGS_ENABLED(flag)` in macro
4. Include `app_messages.h`

### Debug Command Reference

```bash
# Master control
debug on                    # Enable all debug output
debug off                   # Disable all debug output

# View flags
debug ?                     # List all flags with descriptions

# Set flags
debug <value>               # Set exact flags (hex or decimal)
debug +<value>              # Add flags
debug -<value>              # Remove flags

# File logging
debug save <filename>       # Redirect to file
debug stop                  # Stop file logging
debug status                # Show logging status
```

### Contact and Support

For questions or issues:
- Review this document
- Check source code examples in referenced files
- Consult `CLAUDE.md` in repository root
- Check existing debug implementations in codebase

---

**End of Document**
