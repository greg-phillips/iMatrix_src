# GPS Telemetry Filter Implementation
# Complexity: simple - single focused task with clear requirements

complexity_level: "simple"
prompt_name: "gps_errors_issue"
date: "2026-01-05"
branch: "feature/gps_errors_issue"

title: "Implement Robust GPS Telemetry Filter with State Machine"

background: |
  During testing the GPS we have found the data often contains a lot of noise and errors.
  
  The system is a telematics gateway that must process incoming GPS telemetry (Latitude, 
  Longitude, Altitude, HDOP, and Satellite count) while integrating vehicle wheel speed 
  from the J1939 CAN bus. The goal is to provide a single, clean, filtered coordinate 
  point that handles three specific vehicle scenarios: driving, stationary (engine on 
  or off), and being towed.

task: |
  Implement a robust state-machine filter that uses a recursive smoothing (alpha-beta) approach.
  
  ## Requirements & Logic
  
  ### Data Structures
  Define a TelematicsTracker struct to persist state, including:
  - Last valid Lat/Lon/Alt
  - Motion state
  - Stationary confirmation counter
  - Initialization status
  
  ### Initialization
  The tracker should initialize its "home" position only after receiving a high-confidence 
  fix (HDOP < 2.0 and Sats > 5).
  
  ### The Gatekeeper (Pre-Filtering)
  
  **Signal Integrity:** Discard points where Satellites < 4 or HDOP > 3.5.
  
  **Horizontal Gross Error:** Calculate the distance from the last known good point using 
  the Haversine formula. If distance > 1,000 meters (within a 1s interval), discard as a 
  multipath jump.
  
  **Vertical Gross Error (Altitude):** If the vehicle is stationary or moving slowly, an 
  altitude change of > 50 meters between 1s samples is physically impossible. Use this as 
  a trigger to discard the horizontal data as well, as it indicates a multipath reflection.
  
  ### State Machine Logic
  
  **State: MOVING** - Triggered if j1939_speed > 0.3 m/s OR if gps_distance > 15 meters 
  consistently without J1939 speed (detecting a Towed state).
  
  **State: STATIONARY** - Triggered if j1939_speed == 0 AND gps_distance < 5 meters for 
  at least 10 consecutive samples.
  
  ### Smoothing Filter
  
  Use the recursive formula: Output = LastValid + (Gain Ã— (New - LastValid))
  
  **Dynamic Gain:**
  - If STATIONARY, set gain = 0.01 to lock the position and ignore drift.
  - If MOVING, calculate gain = 1.0 / (hdop + 1.2), clamped at a maximum of 0.75.
  
  ## Code Interface
  
  Implement the following function:
  
  ```c
  void process_telematics_update(
      double raw_lat, 
      double raw_lon, 
      double raw_alt, 
      float hdop, 
      int num_sats, 
      float j1939_speed, 
      double *out_lat, 
      double *out_lon, 
      double *out_alt
  );
  ```
  
  ## Implementation Constraints
  
  - **Standard Headers Only:** Use only math.h and stdint.h.
  - **Memory Efficiency:** Avoid printf, malloc, or any heap allocation. Use static or 
    passed-in pointers for state.
  - **Robustness:** Gracefully handle j1939_speed, using a special value flag if the speed is not available, from routine imx_get_j1939_speed() in: /home/greg/iMatrix/iMatrix_Client/Fleet-Connect-1/OBD2/get_J1939_sensors.c
  - **Documentation:** Provide detailed comments explaining how the Altitude check acts 
    as a "Z-gate" to protect the Latitude/Longitude integrity.

files_to_modify:
  - path: "iMatrix/get_location.c"
    focus: "Review existing GPS handling implementation"
  - path: "iMatrix/location/process_nmea.c"
    focus: "Review NMEA processing for integration points"

notes: |
  Ask any questions you need to before starting the work.

  ## Questions for Greg

     Before starting implementation, I have a few clarifying questions:

     1. **Filter Location**: Should the filter be a new module in `iMatrix/location/` or integrated directly into `process_nmea.c`? I recommend a separate module for maintainability.

     2. **Existing Kalman Filter**: There's an existing Kalman filter in `kalman_filter/` that's disabled. Should we:
        - (A) Replace it with the new telematics filter
        - (B) Keep both and make them selectable via compile flag
        - (C) Remove the old Kalman filter entirely

     3. **Debug Output**: Should filter rejections be logged with the existing `DEBUGS_FOR_GPS` flag or a new dedicated flag?

     4. **State Persistence**: Should the filter state persist across system restarts (saved to flash), or reset on each boot?

     5. **Units Clarification**: The YAML spec says `j1939_speed > 0.3 m/s` but `imx_get_j1939_speed()` returns km/h. I'll convert internally. Is this correct understanding?


     Answers to the questions:
     1. Separate module for maintainability.
     2. A
     3. A new dedicated flag.
     4. Reset on each boot.
     5. Answer: Yes, convert internally.

     Consider these additional items and determine if they are needed.

     Initialization Guard: The plan initializes on the first high-confidence fix ($HDOP < 2.0$).
      To prevent "seeding" the filter with a transient multipath point that happens to have a low HDOP, consider requiring 3 consecutive samples to be within $10\text{m}$ of each other before setting the initial last_lat/last_lon.Hysteresis
      for Moving $\to$ Stationary: The transition to STATIONARY requires 10 consecutive samples. However, ensure the transition from STATIONARY to MOVING is immediate (1 or 2 samples) to ensure trips aren't "clipped" at the start of a drive.
