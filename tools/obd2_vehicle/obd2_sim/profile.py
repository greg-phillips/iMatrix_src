"""
Vehicle Profile Loader for OBD2 Vehicle Simulator.

Loads and manages vehicle profile data from JSON files generated by trace analysis.
Supports profile schema v1.1 which includes trace characteristics, polling patterns,
dynamic values, and broadcast message configurations.
"""

import json
import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, List, Dict, Any

logger = logging.getLogger(__name__)


@dataclass
class ECUConfig:
    """Configuration for a single ECU."""
    name: str
    index: int
    physical_request_id: int
    response_id: int
    padding_byte: int
    response_delay_ms: float
    extended_frame: bool = False

    @classmethod
    def from_dict(cls, data: dict) -> 'ECUConfig':
        """Create ECUConfig from profile dictionary."""
        # Handle both string (hex) and integer IDs
        response_id = data.get('response_id', '0x7E8')
        if isinstance(response_id, str):
            response_id = int(response_id, 16)

        physical_req_id = data.get('physical_request_id', '0x7E0')
        if isinstance(physical_req_id, str):
            physical_req_id = int(physical_req_id, 16)

        padding_byte = data.get('padding_byte', '0x00')
        if isinstance(padding_byte, str):
            padding_byte = int(padding_byte, 16)

        return cls(
            name=data.get('name', f"ECU_{data.get('index', 0)}"),
            index=data.get('index', 0),
            physical_request_id=physical_req_id,
            response_id=response_id,
            padding_byte=padding_byte,
            response_delay_ms=data.get('response_delay_ms', 8.0),
            extended_frame=data.get('extended_frame', False),
        )


@dataclass
class BroadcastConfig:
    """Configuration for a single broadcast message."""
    can_id: int
    interval_ms: float
    dlc: int
    pattern_type: str  # 'static' or 'dynamic'

    # For static patterns
    static_data: Optional[bytes] = None

    # For dynamic patterns
    template: Optional[bytes] = None
    static_bytes: List[int] = field(default_factory=list)
    varying_bytes: List[dict] = field(default_factory=list)

    # Runtime state for rolling counters
    counter_values: Dict[int, int] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: dict) -> 'BroadcastConfig':
        """Create BroadcastConfig from profile dictionary."""
        can_id = int(data['can_id'], 16)
        interval_ms = data['interval_ms']
        dlc = data['dlc']
        pattern = data.get('pattern', {})
        pattern_type = pattern.get('type', 'static')

        if pattern_type == 'static':
            static_data = bytes.fromhex(pattern.get('data', '').replace(' ', ''))
            return cls(
                can_id=can_id,
                interval_ms=interval_ms,
                dlc=dlc,
                pattern_type='static',
                static_data=static_data,
            )
        else:
            # Dynamic pattern
            template_hex = pattern.get('template', '')
            # Replace XX placeholders with 00 for template
            template_clean = template_hex.replace(' ', '').replace('XX', '00').replace('xx', '00')
            template = bytes.fromhex(template_clean) if template_clean else None

            return cls(
                can_id=can_id,
                interval_ms=interval_ms,
                dlc=dlc,
                pattern_type='dynamic',
                template=template,
                static_bytes=pattern.get('static_bytes', []),
                varying_bytes=pattern.get('varying_bytes', []),
            )


class VehicleProfile:
    """
    Loads and manages vehicle profile data from parsed trace files.

    Supports profile schema v1.1 which includes:
    - trace_characteristics: Operating mode, timing metadata
    - polling_patterns: Query frequency analysis per PID
    - dynamic_values: Value ranges for PIDs with variation (Phase 2)
    - broadcast_messages: Background CAN traffic patterns
    """

    def __init__(self, profile_path: str):
        """
        Load vehicle profile from JSON file.

        Args:
            profile_path: Path to vehicle profile JSON file

        Raises:
            FileNotFoundError: If profile file doesn't exist
            json.JSONDecodeError: If profile is invalid JSON
            ValueError: If profile fails validation
        """
        self.profile_path = Path(profile_path)
        self._data: Dict[str, Any] = {}
        self._ecus: List[ECUConfig] = []
        self._broadcast_configs: List[BroadcastConfig] = []
        self._response_lookup: Dict[tuple, Dict[int, bytes]] = {}
        self._supported_pids: Dict[int, set] = {}  # service -> set of PIDs

        self._load()
        self._validate()
        self._build_lookup_tables()

    @classmethod
    def load(cls, profile_path: str) -> 'VehicleProfile':
        """
        Load vehicle profile from JSON file.

        Args:
            profile_path: Path to vehicle profile JSON file

        Returns:
            Loaded VehicleProfile instance
        """
        return cls(profile_path)

    @property
    def name(self) -> str:
        """Get profile name."""
        # Try multiple name sources
        info = self._data.get('vehicle_info', {})
        if 'make' in info and 'model' in info:
            year = info.get('year', '')
            return f"{info['make']}_{info['model']}_{year}".strip('_')
        return self.profile_name

    @property
    def version(self) -> str:
        """Get profile version."""
        return self.profile_version

    def _load(self) -> None:
        """Load profile from JSON file."""
        logger.debug(f"Loading profile from: {self.profile_path}")

        if not self.profile_path.exists():
            raise FileNotFoundError(f"Profile file not found: {self.profile_path}")

        with open(self.profile_path, 'r') as f:
            self._data = json.load(f)

        self.profile_version = self._data.get('profile_version', '1.0')
        self.profile_name = self._data.get('profile_name', 'Unknown')

        logger.debug(f"Loaded profile: {self.profile_name} (v{self.profile_version})")

    def _validate(self) -> None:
        """Validate profile structure."""
        # Accept either 'responses' or 'obd2_responses'
        has_responses = 'responses' in self._data or 'obd2_responses' in self._data
        if not has_responses:
            # Allow minimal profiles without responses for testing
            logger.debug("Profile has no responses - operating in minimal mode")

        # Validate ECU configuration
        if 'ecus' in self._data:
            for ecu_data in self._data['ecus']:
                if 'response_id' not in ecu_data:
                    raise ValueError("ECU configuration missing 'response_id'")

    def _build_lookup_tables(self) -> None:
        """Build internal lookup tables for fast response retrieval."""
        # Build ECU configs
        if 'ecus' in self._data:
            self._ecus = [ECUConfig.from_dict(e) for e in self._data['ecus']]
        else:
            # Default single ECU
            self._ecus = [ECUConfig(
                name="ECU_0",
                index=0,
                physical_request_id=0x7E0,
                response_id=0x7E8,
                padding_byte=0x00,
                response_delay_ms=8.0,
            )]

        # Build broadcast configs - handle both formats
        self._build_broadcast_configs()

        # Build response lookup - handle both formats
        if 'obd2_responses' in self._data:
            self._build_lookup_from_obd2_responses()
        elif 'responses' in self._data:
            self._build_lookup_from_responses()

        logger.debug(f"Built lookup tables: {len(self._response_lookup)} response entries")

    def _build_broadcast_configs(self) -> None:
        """Build broadcast message configurations."""
        if 'broadcast_messages' in self._data:
            for b in self._data['broadcast_messages']:
                # Handle simplified test fixture format
                if 'pattern_type' in b and 'pattern' not in b:
                    # Convert simplified format to expected format
                    bc = self._build_broadcast_from_simple(b)
                else:
                    bc = BroadcastConfig.from_dict(b)
                self._broadcast_configs.append(bc)

    def _build_broadcast_from_simple(self, data: dict) -> BroadcastConfig:
        """Build BroadcastConfig from simplified format."""
        can_id_str = data.get('can_id', '0x0000')
        can_id = int(can_id_str, 16) if isinstance(can_id_str, str) else can_id_str

        pattern_type = data.get('pattern_type', 'static')

        if pattern_type == 'static':
            static_data_str = data.get('static_data', '')
            static_data = bytes.fromhex(static_data_str.replace(' ', '')) if static_data_str else bytes(8)
            return BroadcastConfig(
                can_id=can_id,
                interval_ms=data.get('interval_ms', 100),
                dlc=data.get('dlc', 8),
                pattern_type='static',
                static_data=static_data,
            )
        else:
            template_str = data.get('template', '00' * 8)
            template = bytes.fromhex(template_str.replace(' ', ''))
            return BroadcastConfig(
                can_id=can_id,
                interval_ms=data.get('interval_ms', 100),
                dlc=data.get('dlc', 8),
                pattern_type='dynamic',
                template=template,
                varying_bytes=data.get('varying_bytes', []),
            )

    def _build_lookup_from_obd2_responses(self) -> None:
        """Build lookup from obd2_responses format (ECU -> Service -> PID)."""
        obd2_responses = self._data.get('obd2_responses', {})

        for ecu_key, services in obd2_responses.items():
            try:
                ecu_id = int(ecu_key, 16)
            except ValueError:
                logger.warning(f"Invalid ECU key: {ecu_key}")
                continue

            for service_key, pids in services.items():
                try:
                    service = int(service_key, 16)
                except ValueError:
                    logger.warning(f"Invalid service key: {service_key}")
                    continue

                if service not in self._supported_pids:
                    self._supported_pids[service] = set()

                for pid_key, entry in pids.items():
                    try:
                        pid = int(pid_key, 16)
                    except ValueError:
                        continue

                    self._supported_pids[service].add(pid)

                    # Get response data
                    if isinstance(entry, dict):
                        if 'multi_frame' in entry and entry['multi_frame']:
                            # Multi-frame response
                            self._add_response(service, pid, ecu_id, entry)
                        elif 'frames' in entry:
                            # Multi-frame with frames
                            self._add_response(service, pid, ecu_id, entry)
                        elif 'response' in entry and entry['response']:
                            # Single-frame response
                            response_str = entry['response']
                            response_bytes = bytes.fromhex(response_str.replace(' ', ''))
                            self._add_response(service, pid, ecu_id, response_bytes)
                    elif isinstance(entry, str):
                        # Direct response string
                        response_bytes = bytes.fromhex(entry.replace(' ', ''))
                        self._add_response(service, pid, ecu_id, response_bytes)

    def _build_lookup_from_responses(self) -> None:
        """Build lookup from responses format (Service -> PID -> ECU)."""
        responses = self._data.get('responses', {})

        for service_key, service_data in responses.items():
            try:
                if service_key.startswith('service_'):
                    service = int(service_key.split('_')[1], 16)
                else:
                    continue
            except (ValueError, IndexError):
                logger.warning(f"Invalid service key: {service_key}")
                continue

            if service not in self._supported_pids:
                self._supported_pids[service] = set()

            for key, entry in service_data.items():
                # Skip metadata fields
                if key in ('description', 'request'):
                    continue

                # Check if this is a direct ECU response (service-level, no PID)
                # ECU response IDs are 0x7E8-0x7EF range
                if key.startswith('0x7E') and isinstance(entry, str):
                    # Direct ECU response at service level (e.g., service_03)
                    try:
                        ecu_id = int(key, 16)
                        response_bytes = bytes.fromhex(entry.replace(' ', ''))
                        self._add_response(service, None, ecu_id, response_bytes)
                    except ValueError:
                        logger.warning(f"Invalid ECU ID or response: {key}")
                    continue

                # Otherwise, this is a PID entry with nested ECU responses
                try:
                    if key.startswith('0x'):
                        pid = int(key, 16)
                    else:
                        continue
                except ValueError:
                    logger.warning(f"Invalid PID key: {key}")
                    continue

                self._supported_pids[service].add(pid)

                # Entry should be a dict with ECU responses
                if not isinstance(entry, dict):
                    logger.warning(f"Expected dict for PID entry, got {type(entry)}")
                    continue

                # Check for multi-frame at PID level (ECU ID inside frames)
                if entry.get('multi_frame') and 'frames' in entry:
                    # Multi-frame response with ECU ID inside frames
                    frames = entry.get('frames', [])
                    if frames and isinstance(frames[0], dict):
                        ecu_id_str = frames[0].get('ecu_id', '0x7E8')
                        try:
                            ecu_id = int(ecu_id_str, 16)
                            # Build multi-frame response dict
                            mf_response = {
                                'multi_frame': True,
                                'total_length': entry.get('total_length', 0),
                                'frames': [f.get('data', '') for f in frames]
                            }
                            self._add_response(service, pid, ecu_id, mf_response)
                        except ValueError:
                            logger.warning(f"Invalid ECU ID in frames: {ecu_id_str}")
                    continue

                for ecu_key, value in entry.items():
                    if ecu_key.startswith('0x7E'):
                        try:
                            ecu_id = int(ecu_key, 16)
                            if isinstance(value, str):
                                response_bytes = bytes.fromhex(value.replace(' ', ''))
                                self._add_response(service, pid, ecu_id, response_bytes)
                            elif isinstance(value, dict) and 'frames' in value:
                                self._add_response(service, pid, ecu_id, value)
                        except ValueError:
                            logger.warning(f"Invalid ECU ID: {ecu_key}")

    def _add_response(self, service: int, pid: Optional[int], ecu_id: int, response) -> None:
        """Add a response to the lookup table."""
        key = (service, pid)
        if key not in self._response_lookup:
            self._response_lookup[key] = {}
        self._response_lookup[key][ecu_id] = response

    def get_response(self, service: int, pid: Optional[int], ecu_id: int) -> Optional[Any]:
        """
        Get response data for a specific service/PID from a specific ECU.

        Args:
            service: OBD2 service number
            pid: PID number (None for service-only requests)
            ecu_id: ECU response ID (e.g., 0x7E8)

        Returns:
            Response bytes for single-frame, dict for multi-frame, or None if not found
        """
        key = (service, pid)
        responses = self._response_lookup.get(key, {})
        return responses.get(ecu_id)

    def get_ecus(self) -> List[ECUConfig]:
        """Get list of ECU configurations."""
        return self._ecus

    def get_ecu_by_response_id(self, response_id: int) -> Optional[ECUConfig]:
        """Get ECU configuration by response ID."""
        for ecu in self._ecus:
            if ecu.response_id == response_id:
                return ecu
        return None

    def get_broadcast_messages(self) -> List[BroadcastConfig]:
        """Get list of broadcast message configurations."""
        return self._broadcast_configs

    def get_vin(self) -> str:
        """Get Vehicle Identification Number."""
        return self._data.get('vehicle_info', {}).get('vin', 'Unknown')

    def supports_pid(self, service: int, pid: int) -> bool:
        """Check if a PID is supported for a given service."""
        return pid in self._supported_pids.get(service, set())

    def get_supported_pids(self, service: int) -> set:
        """Get set of supported PIDs for a service."""
        return self._supported_pids.get(service, set())

    # Profile metadata methods (from trace analysis)

    def get_trace_characteristics(self) -> dict:
        """Get trace analysis characteristics."""
        return self._data.get('trace_characteristics', {
            'operating_mode': 'unknown',
            'passive_phase_duration_ms': 0,
            'first_obd2_request_ms': 0,
            'total_requests': 0,
            'continuously_polled_pids': [],
        })

    def get_polling_patterns(self) -> dict:
        """Get polling pattern analysis per PID."""
        return self._data.get('polling_patterns', {})

    def get_dynamic_values(self) -> dict:
        """Get dynamic value ranges for Phase 2 integration."""
        return self._data.get('dynamic_values', {})

    # Utility methods

    def get_operating_mode(self) -> str:
        """Get trace operating mode ('discovery' or 'pui')."""
        return self.get_trace_characteristics().get('operating_mode', 'unknown')

    def get_continuously_polled_pids(self) -> List[int]:
        """Get list of PIDs that were continuously polled in the trace."""
        chars = self.get_trace_characteristics()
        polled = chars.get('continuously_polled_pids', [])
        return [p.get('pid') if isinstance(p, dict) else p for p in polled]

    def get_timing(self) -> dict:
        """Get timing configuration."""
        return self._data.get('timing', {
            'p2_response_ms': 8.0,
            'inter_ecu_delay_ms': 8.0,
        })

    def get_vehicle_info(self) -> dict:
        """Get vehicle information."""
        return self._data.get('vehicle_info', {})

    def get_can_config(self) -> dict:
        """Get CAN configuration."""
        return self._data.get('can_config', {
            'bitrate': 500000,
            'functional_request_id': '0x7DF',
            'response_base_id': '0x7E8',
        })

    def get_functional_request_id(self) -> int:
        """Get functional broadcast request ID."""
        can_config = self.get_can_config()
        return int(can_config.get('functional_request_id', '0x7DF'), 16)
