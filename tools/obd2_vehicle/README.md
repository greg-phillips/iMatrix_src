# OBD2 Vehicle Simulator

A Python-based OBD2 vehicle simulator for bench testing telematics gateways. The simulator responds to OBD2 requests with pre-captured vehicle responses, supporting multiple vehicle profiles extracted from PCAN trace files.

## Features

- **Multi-ECU Simulation**: Simulate up to 8 ECUs with correct timing and padding
- **Profile-Based**: Load vehicle profiles from JSON files generated by trace analysis
- **Broadcast Messages**: Generate periodic CAN broadcast messages with rolling counters
- **ISO-TP Support**: Handle multi-frame messages (e.g., VIN retrieval)
- **Terminal UI (TUI)**: Real-time colorful transaction display with auto-scrolling log
- **Virtual CAN Support**: Test without kernel modules using python-can's virtual interface
- **Configurable**: Command-line options for timing, logging, and behavior

## Requirements

- Python 3.8+
- python-can library
- rich library (for TUI mode)
- Linux with SocketCAN support (optional - virtual CAN works without it)
- can-utils package (optional, for testing)

## Installation

```bash
# Clone or navigate to the project directory
cd /path/to/odb2_vehicle

# Create virtual environment (recommended)
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Install package in development mode
pip install -e .
```

## Quick Start

### Option A: Using Virtual CAN (No Kernel Module Required)

The simplest way to test - uses python-can's virtual interface:

```bash
# Run with virtual interface (no root required)
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json \
    --interface-type virtual --interface test_channel

# With Terminal UI for visual monitoring
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json \
    --interface-type virtual --interface test_channel --tui
```

### Option B: Using SocketCAN (Requires Kernel Support)

```bash
# Load vcan module (requires root)
sudo modprobe vcan

# Create virtual CAN interface
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0

# Verify interface
ip link show vcan0

# Run simulator
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json --interface vcan0
```

### Option C: Using USB PCAN Adapter (Hardware CAN Interface)

For testing with real CAN hardware, you can use a PEAK-System PCAN-USB adapter. There are two approaches:

#### Method 1: PCAN via SocketCAN Driver (Recommended for Linux)

```bash
# Load the peak_usb kernel driver
sudo modprobe peak_usb

# Plug in your PCAN-USB adapter - it will appear as can0 (or can1, can2, etc.)
# Verify the interface is detected
ip link show can0

# Configure the CAN interface with 500kbps bitrate (standard OBD2)
sudo ip link set can0 type can bitrate 500000
sudo ip link set up can0

# Run simulator with BMW X3 profile on hardware CAN interface
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json --interface can0

# With TUI visualization for real-time monitoring
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json --interface can0 --tui
```

#### Method 2: PCAN Native Interface (Windows Only)

On Windows, use PEAK's native PCAN driver.

**Step 1: Install PCAN Driver**

Download and install from PEAK-System: https://www.peak-system.com/Drivers.523.0.html

**Step 2: Install Python Dependencies**

Use `python3 -m pip` to ensure packages install for the correct Python version:

```powershell
python3 -m pip install python-can[pcan]
python3 -m pip install rich   # Required for TUI mode
```

**Step 3: Verify PCAN Connection**

Test that python-can can communicate with your adapter:

```powershell
python3 -c "import can; bus = can.Bus(interface='pcan', channel='PCAN_USBBUS1', bitrate=500000); print('PCAN OK'); bus.shutdown()"
```

**Step 4: Run the Simulator**

```powershell
# Basic usage with PCAN-USB
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json ^
    --interface-type pcan --interface PCAN_USBBUS1 --bitrate 500000

# With TUI for real-time monitoring
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json ^
    --interface-type pcan --interface PCAN_USBBUS1 --bitrate 500000 --tui

# With debug logging
python3 -m obd2_sim --profile profiles/BMW_X3_2019.json ^
    --interface-type pcan --interface PCAN_USBBUS1 --bitrate 500000 --log-level debug
```

**Common PCAN Channel Names:**

| Channel | Description |
|---------|-------------|
| `PCAN_USBBUS1` | First PCAN-USB adapter |
| `PCAN_USBBUS2` | Second PCAN-USB adapter |
| `PCAN_PCIBUS1` | PCI CAN card |

**Troubleshooting:**
- Verify adapter works in PCAN-View first
- Use `python3 -m pip` (not just `pip`) to ensure correct Python version
- SocketCAN options (`vcan0`, `can0`) do not work on Windows

**Note:** On Linux, always use Method 1 (SocketCAN) for PCAN adapters. The native PCAN interface type is for Windows only.

### Running Examples

```bash
# Basic usage with TUI visualization
python3 -m obd2_sim -p profiles/BMW_X3_2019.json --tui --interface-type virtual -i test

# With debug logging to file
python3 -m obd2_sim -p profiles/BMW_X3_2019.json --log-level debug --log-file sim.log

# Verbose frame logging
python3 -m obd2_sim -p profiles/BMW_X3_2019.json --log-level debug --log-frames

# Disable broadcast messages
python3 -m obd2_sim -p profiles/BMW_X3_2019.json --disable-broadcast

# Quiet mode (minimal output)
python3 -m obd2_sim -p profiles/BMW_X3_2019.json -q
```

### 3. Test with can-utils

```bash
# In another terminal, send OBD2 requests
# Request supported PIDs (01-20)
cansend vcan0 7DF#0201000000000000

# Monitor responses
candump vcan0

# Request VIN
cansend vcan0 7DF#0209020000000000
```

## Command Line Options

### Required Options

| Option | Description |
|--------|-------------|
| `--profile, -p <FILE>` | Path to vehicle profile JSON file |

### CAN Interface Options

| Option | Default | Description |
|--------|---------|-------------|
| `--interface, -i <IF>` | `vcan0` | CAN interface/channel name |
| `--interface-type <TYPE>` | `socketcan` | CAN interface type (see below) |
| `--bitrate, -b <RATE>` | `500000` | CAN bitrate in bps (ignored for vcan/virtual) |
| `--extended` | disabled | Enable 29-bit extended frame mode |

**Interface Types:**
- `socketcan` - Linux SocketCAN (requires kernel support and root for setup)
- `virtual` - Python-can virtual bus (no kernel support needed, good for testing)
- `pcan` - PEAK-System PCAN adapters
- `kvaser` - Kvaser adapters
- `vector` - Vector adapters
- See python-can documentation for full list

### Value Mode Options

| Option | Default | Description |
|--------|---------|-------------|
| `--value-mode <MODE>` | `static` | Value generation mode |
| `--unsupported-pid <MODE>` | `no-response` | Behavior for unsupported PIDs |

**Value Modes:**
- `static` - Replay captured values from profile (Phase 1)
- `random` - Random values within defined ranges (Phase 2, not yet implemented)
- `scenario` - Scenario-based value sequences (Phase 3, not yet implemented)

**Unsupported PID Modes:**
- `no-response` - Don't respond (causes timeout on tester)
- `nrc-12` - Return NRC 0x12 (SubFunction Not Supported)
- `nrc-11` - Return NRC 0x11 (Service Not Supported)

### Broadcast Options

| Option | Default | Description |
|--------|---------|-------------|
| `--disable-broadcast` | enabled | Disable all broadcast messages |
| `--broadcast-ids <IDS>` | all | Comma-separated hex IDs to enable (e.g., `003C,0130`) |

### Timing Options

| Option | Default | Description |
|--------|---------|-------------|
| `--response-delay <MS>` | from profile | Override base response delay in milliseconds |
| `--inter-ecu-delay <MS>` | from profile | Override delay between ECU responses |
| `--jitter <MS>` | `0` | Random jitter to add to delays |

### Display Options

| Option | Default | Description |
|--------|---------|-------------|
| `--tui` | disabled | Enable Terminal UI with live transaction display |
| `--quiet, -q` | disabled | Quiet mode - minimal output |

### Logging Options

| Option | Default | Description |
|--------|---------|-------------|
| `--log-level <LEVEL>` | `info` | Logging verbosity level (see below) |
| `--log-file <FILE>` | stdout | Log output file path |
| `--log-frames` | disabled | Log all CAN frames (very verbose) |

**Log Levels (from most to least verbose):**

| Level | Description |
|-------|-------------|
| `debug` | Detailed debugging information including internal state changes, message parsing details, and component initialization. Use for troubleshooting. |
| `info` | General operational messages: startup, profile loading, connection status, statistics. Default level for normal operation. |
| `warn` | Warning conditions that don't prevent operation but may indicate issues: unsupported PIDs, timing anomalies, configuration concerns. |
| `error` | Error conditions: failed operations, invalid data, communication failures. Always shown unless completely silenced. |

**Logging Examples:**
```bash
# Debug everything to console
python3 -m obd2_sim -p profile.json --log-level debug

# Debug with frame logging (very verbose)
python3 -m obd2_sim -p profile.json --log-level debug --log-frames

# Log to file for later analysis
python3 -m obd2_sim -p profile.json --log-level debug --log-file debug.log

# Quiet operation (errors only)
python3 -m obd2_sim -p profile.json --log-level error

# TUI mode (logging suppressed for clean display)
python3 -m obd2_sim -p profile.json --tui
```

### Operational Options

| Option | Default | Description |
|--------|---------|-------------|
| `--daemon` | disabled | Run as background daemon |
| `--pid-file <FILE>` | none | Write process ID to file (for daemon mode) |
| `--stats-interval <SEC>` | `0` | Print statistics every N seconds (0 = disabled) |

## Creating Vehicle Profiles

Vehicle profiles are generated from PCAN trace files using the trace parser:

```bash
python scripts/trace_parser.py BMW_OneStep.trc profiles/BMW_X3_2019.json
```

The parser extracts:
- OBD2 request/response pairs
- ECU configuration (IDs, padding, timing)
- Broadcast message patterns
- VIN and vehicle information

See `TRACE_PARSER_SPEC.md` for parser documentation.

## Project Structure

```
obd2_vehicle/
├── obd2_sim/                   # Main package
│   ├── __init__.py
│   ├── __main__.py             # Entry point for python -m
│   ├── cli.py                  # Command line interface
│   ├── config.py               # Configuration dataclasses
│   ├── profile.py              # Vehicle profile loader
│   ├── can_id.py               # CAN identifier handling
│   ├── request.py              # Request matching/parsing
│   ├── response.py             # Response generation
│   ├── value_provider.py       # Value providers (static)
│   ├── isotp.py                # ISO-TP handler
│   ├── broadcast.py            # Broadcast generator
│   ├── simulator.py            # Main simulator class
│   ├── logging_config.py       # Logging configuration
│   ├── stats.py                # Statistics tracking
│   └── visualization/          # Terminal UI components
│       ├── __init__.py
│       ├── tui.py              # Main TUI controller
│       ├── decoder.py          # OBD2 PID decoder
│       ├── transaction_log.py  # Scrolling transaction log
│       └── panels.py           # Stats/ECU status panels
├── profiles/                   # Vehicle profiles
├── tests/                      # Test suite
├── scripts/                    # Utility scripts
└── docs/                       # Documentation
```

## Supported OBD2 Services

| Service | Name | Support |
|---------|------|---------|
| 0x01 | Current Data | Full |
| 0x02 | Freeze Frame | Full |
| 0x03 | Stored DTCs | Full |
| 0x04 | Clear DTCs | Full |
| 0x07 | Pending DTCs | Full |
| 0x09 | Vehicle Info | Full (VIN) |
| 0x0A | Permanent DTCs | Full |

## License

MIT License - See LICENSE file for details.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make changes with tests
4. Submit a pull request

## Related Documentation

- `OBD2_SIMULATOR_IMPLEMENTATION_PLAN.md` - Detailed implementation plan
- `TRACE_PARSER_SPEC.md` - Trace file parser specification
- `obd2_vehicle_spec.md` - OBD2 protocol specification
- `EXTENDED_FRAME_SUPPORT_PLAN.md` - 29-bit frame support plan
