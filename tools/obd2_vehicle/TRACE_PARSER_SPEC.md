# OBD2 Trace Parser Specification

**Document Version**: 1.1
**Date**: 2025-12-13
**Last Updated**: 2025-12-13
**Author**: Claude Code Analysis
**Status**: Draft

---

## 1. Overview

This document defines the file formats, parsing algorithms, and output structure for a tool that processes PCAN trace files and generates OBD2 vehicle profiles for the bench test simulator.

### 1.1 Processing Pipeline

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  PCAN Trace     │────▶│  Trace Parser   │────▶│  Vehicle        │
│  File (.trc)    │     │  Script         │     │  Profile (.json)│
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 1.2 Goals

1. Automatically extract all OBD2 request/response pairs
2. Identify and catalog background broadcast messages
3. Detect multi-ECU responses and timing
4. Generate machine-readable profiles for the simulator
5. **Detect trace operating mode** (Discovery vs Passive-Until-Interrogated)
6. **Track dynamic value variations** across repeated PID queries
7. **Analyze query patterns** for polling frequency and PID prioritization

### 1.3 Supported Trace Operating Modes

The parser must detect and handle two distinct operating modes observed in real-world traces:

| Mode | Description | Characteristics |
|------|-------------|-----------------|
| **Discovery Mode** | Full PID enumeration scan | OBD2 queries start early, sequential PID discovery, single query per PID |
| **PUI Mode** (Passive Until Interrogated) | Passive listening followed by targeted polling | Extended broadcast-only phase, limited discovery, continuous polling of key PIDs |

#### 1.3.1 Discovery Mode Example (BMW_OneStep.trc)
```
Time 0ms:     First OBD2 request (PID 0x00)
Time 100ms:   Sequential PID queries
...
Pattern:      Query each supported PID once, collect static values
```

#### 1.3.2 PUI Mode Example (BMW_PUI.trc)
```
Time 0ms:     Broadcast messages only (passive listening)
Time 11731ms: First OBD2 request (11.7 second delay)
Time 12000ms: Limited discovery (supported PIDs only)
Time 16000ms: Continuous polling of RPM, Speed, etc.
Pattern:      Passive phase → Discovery → Continuous monitoring
```

---

## 2. Input Format: PCAN Trace File (.trc)

### 2.1 File Structure

PCAN-View generates trace files with the following structure:

```
;$FILEVERSION=1.1
;$STARTTIME=46004.4864457292
;
;   Start time: 12/13/2025 11:40:28.911.0
;   Generated by PCAN-View v5.3.2.952
;
;   Message Number
;   |         Time Offset (ms)
;   |         |        Type
;   |         |        |        ID (hex)
;   |         |        |        |     Data Length
;   |         |        |        |     |   Data Bytes (hex) ...
;   |         |        |        |     |   |
;---+--   ----+----  --+--  ----+---  +  -+ -- -- -- -- -- -- --
     1)         6.3  Rx         07C1  8  0C 18 00 0C FF 00 01 00
     2)        66.0  Rx         003C  8  AF A1 02 12 01 00 2A FF
```

### 2.2 Line Format Specification

#### 2.2.1 Header Lines

Lines starting with `;` are comments/headers:

| Pattern | Description |
|---------|-------------|
| `;$FILEVERSION=X.X` | Trace file format version |
| `;$STARTTIME=XXXXX.XXXX` | OLE Automation date (days since 1899-12-30) |
| `;   Start time: MM/DD/YYYY HH:MM:SS.mmm.u` | Human-readable timestamp |
| `;   Generated by PCAN-View vX.X.X.X` | Generator version |
| `;---+--` | Column header separator |

#### 2.2.2 Message Lines

Data lines follow this fixed-width format:

```
NNNNN)  TTTTTTTT.T  DD  IIIIIIII  L  BB BB BB BB BB BB BB BB
```

| Field | Position | Width | Description |
|-------|----------|-------|-------------|
| Message Number | 0-5 | 6 | Right-justified, followed by `)` |
| Time Offset | 8-18 | 10 | Milliseconds from start, 1 decimal |
| Direction | 20-23 | 4 | `Rx` or `Tx` |
| CAN ID | 25-32 | 8 | Hex, right-justified (may include extended flag) |
| DLC | 34-35 | 2 | Data Length Code (0-8) |
| Data Bytes | 37+ | Variable | Space-separated hex bytes |

### 2.3 Parsing Regular Expression

```python
# Python regex for parsing message lines
import re

MESSAGE_PATTERN = re.compile(
    r'^\s*(\d+)\)\s+'           # Message number
    r'([\d.]+)\s+'              # Time offset (ms)
    r'(Rx|Tx)\s+'               # Direction
    r'([0-9A-Fa-f]+)\s+'        # CAN ID (hex)
    r'(\d+)\s+'                 # DLC
    r'((?:[0-9A-Fa-f]{2}\s*)+)' # Data bytes
    r'\s*$'
)

def parse_line(line):
    """Parse a single trace line into components."""
    match = MESSAGE_PATTERN.match(line)
    if not match:
        return None

    msg_num = int(match.group(1))
    time_ms = float(match.group(2))
    direction = match.group(3)
    can_id = int(match.group(4), 16)
    dlc = int(match.group(5))
    data_hex = match.group(6).strip()
    data_bytes = bytes.fromhex(data_hex.replace(' ', ''))

    return {
        'msg_num': msg_num,
        'time_ms': time_ms,
        'direction': direction,
        'can_id': can_id,
        'dlc': dlc,
        'data': data_bytes
    }
```

### 2.4 Sample Input Lines

```
     1)         6.3  Rx         07C1  8  0C 18 00 0C FF 00 01 00
   406)     17617.4  Rx         07DF  8  02 01 00 00 00 00 00 00
   407)     17625.7  Rx         07E8  8  06 41 00 BE 3F A8 13 00
   506)     20525.6  Rx         07E8  8  10 14 49 02 01 35 55 58
   507)     20526.2  Rx         07E0  8  30 00 00 00 00 00 00 00
```

---

## 3. Message Classification

### 3.1 CAN ID Categories

The parser must classify messages into these categories:

| Category | CAN ID Range | Description |
|----------|--------------|-------------|
| OBD2_REQUEST | `0x7DF` | Functional broadcast request |
| OBD2_PHYSICAL_REQUEST | `0x7E0` - `0x7E7` | Physical addressing request |
| OBD2_RESPONSE | `0x7E8` - `0x7EF` | ECU responses |
| BROADCAST | All others | Background vehicle messages |

```python
def classify_message(can_id):
    """Classify a CAN message by its ID."""
    if can_id == 0x7DF:
        return 'OBD2_REQUEST'
    elif 0x7E0 <= can_id <= 0x7E7:
        return 'OBD2_PHYSICAL_REQUEST'
    elif 0x7E8 <= can_id <= 0x7EF:
        return 'OBD2_RESPONSE'
    else:
        return 'BROADCAST'
```

### 3.2 ISO-TP Frame Types

OBD2 messages use ISO-TP framing. Detect frame type from first byte:

| First Byte | Frame Type | Description |
|------------|------------|-------------|
| `0x0N` (N=0-7) | Single Frame | Complete message, N = length |
| `0x1N` | First Frame | Multi-frame start, length in bytes 0-1 |
| `0x2N` | Consecutive Frame | Continuation, N = sequence (0-F) |
| `0x3N` | Flow Control | Control message from receiver |

```python
def get_isotp_frame_type(first_byte):
    """Determine ISO-TP frame type from first data byte."""
    pci = (first_byte >> 4) & 0x0F

    if pci == 0:
        return 'SINGLE_FRAME'
    elif pci == 1:
        return 'FIRST_FRAME'
    elif pci == 2:
        return 'CONSECUTIVE_FRAME'
    elif pci == 3:
        return 'FLOW_CONTROL'
    else:
        return 'UNKNOWN'
```

---

## 4. Request/Response Extraction Algorithm

### 4.1 State Machine

```
                         ┌──────────────────┐
                         │      IDLE        │
                         └────────┬─────────┘
                                  │ OBD2 Request (0x7DF)
                                  ▼
                         ┌──────────────────┐
                         │ WAITING_RESPONSE │◀───────────┐
                         └────────┬─────────┘            │
                                  │ Response (0x7E8-0x7EF)
                                  ▼                      │
                    ┌─────────────────────────┐          │
                    │  Check Frame Type       │          │
                    └─────┬───────────┬───────┘          │
                          │           │                  │
               Single Frame│           │First Frame      │
                          │           │                  │
                          ▼           ▼                  │
              ┌───────────────┐ ┌─────────────────┐      │
              │ STORE_RESPONSE│ │WAITING_MULTIFRAME│     │
              └───────┬───────┘ └────────┬────────┘      │
                      │                  │               │
                      │    Consecutive   │               │
                      │    Frames        │               │
                      │         ┌────────┘               │
                      │         ▼                        │
                      │  ┌─────────────────┐             │
                      │  │ACCUMULATE_FRAMES│─────────────┤
                      │  └────────┬────────┘  Timeout    │
                      │           │ Complete             │
                      │           ▼                      │
                      │  ┌─────────────────┐             │
                      └─▶│  STORE_COMPLETE │─────────────┘
                         └─────────────────┘  Next Request
```

### 4.2 Extraction Logic

```python
class OBD2Extractor:
    """
    Enhanced OBD2 request/response extractor with support for:
    - Multiple operating modes (Discovery, PUI)
    - Dynamic value tracking across repeated queries
    - Polling pattern analysis
    """

    # Response timeout in milliseconds
    RESPONSE_TIMEOUT_MS = 100.0

    # Passive phase threshold - if first OBD2 request is after this time,
    # trace is considered PUI (Passive Until Interrogated) mode
    PASSIVE_PHASE_THRESHOLD_MS = 5000.0

    # Known OBD2 request IDs
    REQUEST_IDS = {0x7DF}
    PHYSICAL_REQUEST_IDS = set(range(0x7E0, 0x7E8))
    RESPONSE_IDS = set(range(0x7E8, 0x7F0))

    # PIDs that typically have dynamic values
    DYNAMIC_PIDS = {0x05, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x1F, 0x2F, 0x33}

    def __init__(self):
        self.requests = []
        self.responses = {}  # keyed by (service, pid)
        self.current_request = None
        self.current_request_time = None
        self.pending_multiframe = {}  # keyed by ecu_id

        # NEW: Track query timing for pattern analysis
        self.query_times = {}  # keyed by (service, pid) -> list of timestamps
        self.first_obd2_time = None  # Time of first OBD2 request
        self.first_message_time = None  # Time of first message (any type)

        # NEW: Track dynamic values per PID per ECU
        self.dynamic_values = {}  # keyed by (service, pid, ecu_id) -> list of values

        # NEW: Operating mode detection
        self.operating_mode = None  # 'discovery' or 'pui'

    def process_message(self, msg):
        """Process a single CAN message."""
        can_id = msg['can_id']
        time_ms = msg['time_ms']
        data = msg['data']

        # Track first message time
        if self.first_message_time is None:
            self.first_message_time = time_ms

        # Check for timeout on pending request
        if self.current_request:
            if time_ms - self.current_request_time > self.RESPONSE_TIMEOUT_MS:
                self._finalize_request()

        # Handle OBD2 requests
        if can_id in self.REQUEST_IDS:
            self._handle_request(msg)

        # Handle OBD2 responses
        elif can_id in self.RESPONSE_IDS:
            self._handle_response(msg)

        # Handle flow control (from tester)
        elif can_id in self.PHYSICAL_REQUEST_IDS:
            self._handle_flow_control(msg)

    def _handle_request(self, msg):
        """Process an OBD2 request message."""
        # Finalize any pending request
        if self.current_request:
            self._finalize_request()

        data = msg['data']
        length = data[0] & 0x0F
        service = data[1]
        pid = data[2] if length >= 2 else None
        time_ms = msg['time_ms']

        # Track first OBD2 request time for mode detection
        if self.first_obd2_time is None:
            self.first_obd2_time = time_ms
            self._detect_operating_mode()

        # Track query timing for polling analysis
        key = (service, pid)
        if key not in self.query_times:
            self.query_times[key] = []
        self.query_times[key].append(time_ms)

        self.current_request = {
            'time_ms': time_ms,
            'service': service,
            'pid': pid,
            'raw_data': data.hex(' ').upper(),
            'responses': {}
        }
        self.current_request_time = time_ms

    def _handle_response(self, msg):
        """Process an OBD2 response message."""
        if not self.current_request:
            return

        can_id = msg['can_id']
        data = msg['data']
        ecu_id = f"0x{can_id:03X}"

        frame_type = get_isotp_frame_type(data[0])

        if frame_type == 'SINGLE_FRAME':
            # Complete single-frame response
            response_service = data[1]
            if response_service == self.current_request['service'] + 0x40:
                delay_ms = msg['time_ms'] - self.current_request_time

                # Extract data bytes for dynamic tracking
                resp_length = data[0] & 0x0F
                data_bytes = data[3:3 + resp_length - 2] if resp_length > 2 else b''

                self.current_request['responses'][ecu_id] = {
                    'raw_data': data.hex(' ').upper(),
                    'delay_ms': round(delay_ms, 1),
                    'frame_type': 'single',
                    'data_bytes': data_bytes.hex(' ').upper() if data_bytes else ''
                }

                # Track dynamic values for repeated queries
                self._track_dynamic_value(
                    self.current_request['service'],
                    self.current_request['pid'],
                    ecu_id,
                    data_bytes
                )

        elif frame_type == 'FIRST_FRAME':
            # Start of multi-frame response
            total_length = ((data[0] & 0x0F) << 8) | data[1]
            self.pending_multiframe[ecu_id] = {
                'total_length': total_length,
                'frames': [data.hex(' ').upper()],
                'expected_seq': 1,
                'start_time': msg['time_ms']
            }

        elif frame_type == 'CONSECUTIVE_FRAME':
            # Continuation of multi-frame
            if ecu_id in self.pending_multiframe:
                mf = self.pending_multiframe[ecu_id]
                seq = data[0] & 0x0F
                if seq == mf['expected_seq']:
                    mf['frames'].append(data.hex(' ').upper())
                    mf['expected_seq'] = (seq + 1) & 0x0F

                    # Check if complete
                    received_bytes = 6 + (len(mf['frames']) - 1) * 7
                    if received_bytes >= mf['total_length']:
                        delay_ms = mf['start_time'] - self.current_request_time
                        self.current_request['responses'][ecu_id] = {
                            'raw_data': mf['frames'],
                            'delay_ms': round(delay_ms, 1),
                            'frame_type': 'multi',
                            'total_length': mf['total_length']
                        }
                        del self.pending_multiframe[ecu_id]

    def _handle_flow_control(self, msg):
        """Record flow control messages from tester."""
        data = msg['data']
        if (data[0] >> 4) == 3:  # Flow control frame
            if self.current_request:
                self.current_request['flow_control'] = {
                    'can_id': f"0x{msg['can_id']:03X}",
                    'raw_data': data.hex(' ').upper()
                }

    def _detect_operating_mode(self):
        """Detect trace operating mode based on timing."""
        if self.first_obd2_time is None or self.first_message_time is None:
            return

        passive_duration = self.first_obd2_time - self.first_message_time

        if passive_duration > self.PASSIVE_PHASE_THRESHOLD_MS:
            self.operating_mode = 'pui'  # Passive Until Interrogated
        else:
            self.operating_mode = 'discovery'

    def _track_dynamic_value(self, service, pid, ecu_id, data_bytes):
        """Track value samples for dynamic PIDs."""
        if pid not in self.DYNAMIC_PIDS:
            return

        key = (service, pid, ecu_id)
        if key not in self.dynamic_values:
            self.dynamic_values[key] = []

        self.dynamic_values[key].append({
            'time_ms': self.current_request_time,
            'value': data_bytes.hex().upper() if data_bytes else ''
        })

    def _finalize_request(self):
        """Store completed request/response pair."""
        if self.current_request and self.current_request['responses']:
            key = (self.current_request['service'], self.current_request['pid'])

            # Keep first occurrence or merge responses
            if key not in self.responses:
                self.responses[key] = self.current_request
            else:
                # Merge additional ECU responses
                for ecu_id, resp in self.current_request['responses'].items():
                    if ecu_id not in self.responses[key]['responses']:
                        self.responses[key]['responses'][ecu_id] = resp

        self.current_request = None
        self.current_request_time = None

    def get_polling_analysis(self):
        """Analyze polling patterns for each PID."""
        analysis = {}

        for (service, pid), times in self.query_times.items():
            if len(times) < 2:
                analysis[(service, pid)] = {
                    'query_count': len(times),
                    'pattern': 'single_query'
                }
                continue

            # Calculate intervals between queries
            intervals = [times[i+1] - times[i] for i in range(len(times)-1)]
            avg_interval = sum(intervals) / len(intervals)
            min_interval = min(intervals)
            max_interval = max(intervals)

            # Determine if this is continuous polling
            is_polling = len(times) >= 3 and max_interval < 2000  # 2 second threshold

            analysis[(service, pid)] = {
                'query_count': len(times),
                'pattern': 'continuous_polling' if is_polling else 'sporadic',
                'avg_interval_ms': round(avg_interval, 1),
                'min_interval_ms': round(min_interval, 1),
                'max_interval_ms': round(max_interval, 1),
                'first_query_ms': times[0],
                'last_query_ms': times[-1]
            }

        return analysis

    def get_dynamic_value_ranges(self):
        """Get value ranges for dynamic PIDs."""
        ranges = {}

        for (service, pid, ecu_id), samples in self.dynamic_values.items():
            if len(samples) < 2:
                continue

            # Extract numeric values (assuming 2-byte values for RPM, 1-byte for others)
            values = []
            for s in samples:
                hex_val = s['value'].replace(' ', '')
                if hex_val:
                    val = int(hex_val, 16)
                    values.append(val)

            if not values:
                continue

            key = (service, pid, ecu_id)
            ranges[key] = {
                'sample_count': len(values),
                'min_raw': min(values),
                'max_raw': max(values),
                'samples': samples[:10]  # First 10 samples
            }

        return ranges

    def get_trace_summary(self):
        """Get summary of trace characteristics."""
        polling = self.get_polling_analysis()

        # Find most frequently polled PIDs
        polling_pids = [
            (k, v) for k, v in polling.items()
            if v.get('pattern') == 'continuous_polling'
        ]
        polling_pids.sort(key=lambda x: x[1]['query_count'], reverse=True)

        passive_duration = 0
        if self.first_obd2_time and self.first_message_time:
            passive_duration = self.first_obd2_time - self.first_message_time

        return {
            'operating_mode': self.operating_mode,
            'passive_phase_duration_ms': round(passive_duration, 1),
            'first_obd2_request_ms': self.first_obd2_time,
            'total_unique_pids': len(self.responses),
            'total_requests': sum(len(v) for v in self.query_times.values()),
            'continuously_polled_pids': [
                {
                    'service': k[0],
                    'pid': f"0x{k[1]:02X}" if k[1] else None,
                    'query_count': v['query_count'],
                    'avg_interval_ms': v.get('avg_interval_ms', 0)
                }
                for k, v in polling_pids[:10]
            ]
        }
```

---

## 5. Broadcast Message Analysis

### 5.1 Detection Algorithm

Broadcast messages are identified by:
1. CAN ID not in OBD2 range (not 0x7DF-0x7EF)
2. Repetitive transmission at regular intervals

```python
class BroadcastAnalyzer:
    # Minimum occurrences to consider as broadcast
    MIN_OCCURRENCES = 5

    # Interval tolerance (percentage)
    INTERVAL_TOLERANCE = 0.20

    def __init__(self):
        self.messages = {}  # keyed by can_id

    def add_message(self, msg):
        """Add a message for analysis."""
        can_id = msg['can_id']

        # Skip OBD2 messages
        if 0x7DF <= can_id <= 0x7EF:
            return

        if can_id not in self.messages:
            self.messages[can_id] = {
                'times': [],
                'data_samples': [],
                'dlc': msg['dlc']
            }

        self.messages[can_id]['times'].append(msg['time_ms'])
        self.messages[can_id]['data_samples'].append(msg['data'].hex(' ').upper())

    def analyze(self):
        """Analyze collected messages and return broadcast definitions."""
        broadcasts = []

        for can_id, info in self.messages.items():
            if len(info['times']) < self.MIN_OCCURRENCES:
                continue

            # Calculate intervals
            times = info['times']
            intervals = [times[i+1] - times[i] for i in range(len(times)-1)]

            if not intervals:
                continue

            avg_interval = sum(intervals) / len(intervals)

            # Check interval consistency
            consistent = all(
                abs(i - avg_interval) / avg_interval < self.INTERVAL_TOLERANCE
                for i in intervals
            )

            if not consistent:
                continue

            # Analyze data pattern
            pattern = self._analyze_pattern(info['data_samples'])

            broadcasts.append({
                'can_id': f"0x{can_id:04X}",
                'interval_ms': round(avg_interval, 1),
                'dlc': info['dlc'],
                'occurrences': len(info['times']),
                'pattern': pattern,
                'sample_data': info['data_samples'][:10]  # First 10 samples
            })

        return sorted(broadcasts, key=lambda x: int(x['can_id'], 16))

    def _analyze_pattern(self, samples):
        """Analyze data samples to determine pattern type."""
        if len(samples) < 2:
            return {'type': 'unknown'}

        # Convert to byte arrays
        byte_arrays = [bytes.fromhex(s.replace(' ', '')) for s in samples]

        # Check if completely static
        if all(b == byte_arrays[0] for b in byte_arrays):
            return {
                'type': 'static',
                'data': samples[0]
            }

        # Find static and varying bytes
        num_bytes = len(byte_arrays[0])
        static_mask = []
        varying_bytes = []

        for i in range(num_bytes):
            byte_values = [b[i] for b in byte_arrays]
            if len(set(byte_values)) == 1:
                static_mask.append(True)
            else:
                static_mask.append(False)
                varying_bytes.append({
                    'position': i,
                    'values': sorted(set(byte_values))
                })

        # Check for rolling counter pattern
        for vb in varying_bytes:
            values = vb['values']
            if len(values) >= 3:
                # Check if sequential (with wrap)
                diffs = [(values[i+1] - values[i]) % 256 for i in range(len(values)-1)]
                if len(set(diffs)) == 1 and diffs[0] in [1, 255]:  # +1 or -1
                    vb['pattern'] = 'rolling_counter'
                    vb['increment'] = diffs[0] if diffs[0] == 1 else -1

        return {
            'type': 'dynamic',
            'static_bytes': [i for i, s in enumerate(static_mask) if s],
            'varying_bytes': varying_bytes,
            'template': self._create_template(byte_arrays[0], static_mask)
        }

    def _create_template(self, sample, static_mask):
        """Create a data template showing static vs variable bytes."""
        template = []
        for i, is_static in enumerate(static_mask):
            if is_static:
                template.append(f"{sample[i]:02X}")
            else:
                template.append("XX")
        return ' '.join(template)
```

---

## 6. Output Format: Vehicle Profile JSON

### 6.1 Complete Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "OBD2 Vehicle Profile",
  "type": "object",
  "required": ["profile_version", "profile_name", "vehicle_info", "responses"],

  "properties": {
    "profile_version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$"
    },
    "profile_name": {
      "type": "string"
    },
    "created_date": {
      "type": "string",
      "format": "date"
    },
    "source_trace": {
      "type": "string"
    },

    "vehicle_info": {
      "type": "object",
      "properties": {
        "vin": {"type": "string", "minLength": 17, "maxLength": 17},
        "make": {"type": "string"},
        "model": {"type": "string"},
        "year": {"type": "integer"},
        "fuel_type": {"type": "string"},
        "odometer_km": {"type": "number"}
      }
    },

    "can_config": {
      "type": "object",
      "properties": {
        "bitrate": {"type": "integer", "enum": [250000, 500000]},
        "functional_request_id": {"type": "string"},
        "response_base_id": {"type": "string"}
      }
    },

    "timing": {
      "type": "object",
      "properties": {
        "p2_response_ms": {"type": "number"},
        "inter_ecu_delay_ms": {"type": "number"}
      }
    },

    "ecus": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": {"type": "string"},
          "response_id": {"type": "string"},
          "padding_byte": {"type": "string"},
          "response_delay_ms": {"type": "number"}
        }
      }
    },

    "trace_characteristics": {
      "type": "object",
      "description": "Characteristics detected from trace analysis",
      "properties": {
        "operating_mode": {
          "type": "string",
          "enum": ["discovery", "pui"],
          "description": "discovery = immediate PID scan, pui = passive listening then polling"
        },
        "passive_phase_duration_ms": {
          "type": "number",
          "description": "Time from first message to first OBD2 request"
        },
        "first_obd2_request_ms": {
          "type": "number",
          "description": "Timestamp of first OBD2 request"
        },
        "total_requests": {
          "type": "integer",
          "description": "Total number of OBD2 requests in trace"
        }
      }
    },

    "polling_patterns": {
      "type": "object",
      "description": "Polling frequency analysis per PID",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "query_count": {"type": "integer"},
          "pattern": {
            "type": "string",
            "enum": ["single_query", "continuous_polling", "sporadic"]
          },
          "avg_interval_ms": {"type": "number"},
          "min_interval_ms": {"type": "number"},
          "max_interval_ms": {"type": "number"}
        }
      }
    },

    "dynamic_values": {
      "type": "object",
      "description": "Value ranges for PIDs with varying data",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "sample_count": {"type": "integer"},
          "min_raw": {"type": "integer"},
          "max_raw": {"type": "integer"},
          "min_decoded": {"type": "number"},
          "max_decoded": {"type": "number"},
          "unit": {"type": "string"},
          "samples": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "time_ms": {"type": "number"},
                "value": {"type": "string"}
              }
            }
          }
        }
      }
    },

    "responses": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "description": "Service responses keyed by service ID"
      }
    },

    "broadcast_messages": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "can_id": {"type": "string"},
          "interval_ms": {"type": "number"},
          "dlc": {"type": "integer"},
          "pattern": {"type": "object"},
          "sample_data": {"type": "array", "items": {"type": "string"}}
        }
      }
    }
  }
}
```

### 6.2 Response Entry Format

#### 6.2.1 Single-Frame Response

```json
{
  "0x0C": {
    "description": "Engine RPM",
    "request": "02 01 0C 00 00 00 00 00",
    "data_bytes": 2,
    "formula": "((A * 256) + B) / 4",
    "unit": "rpm",
    "dynamic": true,
    "responses": {
      "0x7E8": {
        "data": "04 41 0C 0A 66 00 00 00",
        "delay_ms": 6.2
      },
      "0x7E9": {
        "data": "04 41 0C 0A 6C AA AA AA",
        "delay_ms": 14.7
      }
    }
  }
}
```

#### 6.2.2 Multi-Frame Response

```json
{
  "0x02": {
    "description": "Vehicle Identification Number",
    "request": "02 09 02 00 00 00 00 00",
    "multi_frame": true,
    "total_length": 20,
    "responses": {
      "0x7E8": {
        "frames": [
          "10 14 49 02 01 35 55 58",
          "21 54 53 33 43 35 58 4B",
          "22 30 5A 30 32 36 35 36"
        ],
        "delay_ms": 5.0
      }
    },
    "flow_control": {
      "can_id": "0x7E0",
      "data": "30 00 00 00 00 00 00 00"
    },
    "decoded": {
      "vin": "5UXTS3C5XK0Z02656"
    }
  }
}
```

### 6.3 Broadcast Message Format

#### 6.3.1 Static Pattern

```json
{
  "can_id": "0x07C1",
  "name": "Heartbeat",
  "interval_ms": 1000,
  "dlc": 8,
  "pattern": {
    "type": "static",
    "data": "0C 18 00 0C FF 00 01 00"
  },
  "occurrences": 41
}
```

#### 6.3.2 Dynamic Pattern with Rolling Counter

```json
{
  "can_id": "0x003C",
  "name": "Status_Message_1",
  "interval_ms": 100,
  "dlc": 8,
  "pattern": {
    "type": "dynamic",
    "template": "XX XX 02 12 01 00 2A FF",
    "static_bytes": [2, 3, 4, 5, 6, 7],
    "varying_bytes": [
      {
        "position": 0,
        "pattern": "checksum",
        "values": ["AF", "48", "15", "9B", "C6", "21", "7C", "20", "7D", "9A", "C7", "49", "14", "F3", "F2"]
      },
      {
        "position": 1,
        "pattern": "rolling_counter",
        "range": ["A0", "AF"],
        "increment": 1
      }
    ]
  },
  "sample_data": [
    "AF A1 02 12 01 00 2A FF",
    "48 A2 02 12 01 00 2A FF",
    "15 A3 02 12 01 00 2A FF",
    "9B A4 02 12 01 00 2A FF",
    "C6 A5 02 12 01 00 2A FF",
    "21 A6 02 12 01 00 2A FF",
    "7C A7 02 12 01 00 2A FF",
    "20 A8 02 12 01 00 2A FF",
    "7D A9 02 12 01 00 2A FF",
    "9A AA 02 12 01 00 2A FF"
  ],
  "occurrences": 410
}
```

---

## 7. Complete Parser Implementation

### 7.1 Main Parser Class

```python
#!/usr/bin/env python3
"""
OBD2 Trace Parser - Generates vehicle profiles from PCAN trace files.

Usage: python trace_parser.py <input.trc> [output.json]
"""

import re
import json
import sys
from datetime import datetime
from pathlib import Path


class TraceParser:
    """Main trace file parser."""

    def __init__(self, trace_file):
        self.trace_file = Path(trace_file)
        self.messages = []
        self.metadata = {}

        self.obd2_extractor = OBD2Extractor()
        self.broadcast_analyzer = BroadcastAnalyzer()

    def parse(self):
        """Parse the trace file."""
        with open(self.trace_file, 'r') as f:
            for line in f:
                line = line.rstrip()

                if line.startswith(';'):
                    self._parse_header(line)
                else:
                    msg = parse_line(line)
                    if msg:
                        self.messages.append(msg)
                        self.obd2_extractor.process_message(msg)
                        self.broadcast_analyzer.add_message(msg)

        # Finalize any pending request
        self.obd2_extractor._finalize_request()

    def _parse_header(self, line):
        """Extract metadata from header lines."""
        if line.startswith(';$FILEVERSION='):
            self.metadata['file_version'] = line.split('=')[1]
        elif line.startswith(';$STARTTIME='):
            ole_time = float(line.split('=')[1])
            # Convert OLE Automation date to datetime
            # OLE date is days since 1899-12-30
            from datetime import timedelta
            base = datetime(1899, 12, 30)
            self.metadata['start_datetime'] = base + timedelta(days=ole_time)
        elif 'Generated by' in line:
            self.metadata['generator'] = line.split('Generated by ')[1].strip()

    def generate_profile(self):
        """Generate the output profile."""
        # Analyze broadcasts
        broadcasts = self.broadcast_analyzer.analyze()

        # Get OBD2 responses
        obd2_responses = self.obd2_extractor.responses

        # Detect ECUs
        ecus = self._detect_ecus(obd2_responses)

        # Extract VIN if present
        vin = self._extract_vin(obd2_responses)
        vehicle_info = self._decode_vin(vin) if vin else {}

        # Get trace summary (includes operating mode)
        trace_summary = self.obd2_extractor.get_trace_summary()

        # Get polling patterns
        polling_patterns = self._format_polling_patterns(
            self.obd2_extractor.get_polling_analysis()
        )

        # Get dynamic value ranges
        dynamic_values = self._format_dynamic_values(
            self.obd2_extractor.get_dynamic_value_ranges()
        )

        # Build profile
        profile = {
            'profile_version': '1.1',
            'profile_name': self._generate_profile_name(vehicle_info),
            'created_date': datetime.now().strftime('%Y-%m-%d'),
            'source_trace': self.trace_file.name,

            'vehicle_info': vehicle_info,

            'can_config': {
                'bitrate': 500000,
                'functional_request_id': '0x7DF',
                'response_base_id': '0x7E8'
            },

            'timing': self._calculate_timing(obd2_responses),

            'ecus': ecus,

            # NEW: Trace characteristics
            'trace_characteristics': {
                'operating_mode': trace_summary['operating_mode'],
                'passive_phase_duration_ms': trace_summary['passive_phase_duration_ms'],
                'first_obd2_request_ms': trace_summary['first_obd2_request_ms'],
                'total_requests': trace_summary['total_requests'],
                'continuously_polled_pids': trace_summary['continuously_polled_pids']
            },

            # NEW: Polling patterns per PID
            'polling_patterns': polling_patterns,

            # NEW: Dynamic value ranges
            'dynamic_values': dynamic_values,

            'responses': self._format_responses(obd2_responses),

            'broadcast_messages': broadcasts,

            'metadata': {
                'trace_start_time': self.metadata.get('start_datetime', '').isoformat() if self.metadata.get('start_datetime') else None,
                'trace_duration_ms': self.messages[-1]['time_ms'] if self.messages else 0,
                'total_messages': len(self.messages),
                'generator': self.metadata.get('generator'),
                'analysis_date': datetime.now().strftime('%Y-%m-%d')
            }
        }

        return profile

    def _format_polling_patterns(self, patterns):
        """Format polling patterns for output."""
        output = {}
        for (service, pid), data in patterns.items():
            if data.get('pattern') != 'single_query':  # Only include non-trivial patterns
                key = f"service_{service:02X}_pid_{pid:02X}" if pid else f"service_{service:02X}"
                output[key] = data
        return output

    def _format_dynamic_values(self, ranges):
        """Format dynamic value ranges for output."""
        output = {}
        for (service, pid, ecu_id), data in ranges.items():
            key = f"service_{service:02X}_pid_{pid:02X}_{ecu_id}"
            output[key] = data
        return output

    def _detect_ecus(self, responses):
        """Detect ECUs from response data."""
        ecu_ids = set()
        ecu_delays = {}
        ecu_padding = {}

        for (service, pid), resp_data in responses.items():
            for ecu_id, resp in resp_data['responses'].items():
                ecu_ids.add(ecu_id)

                # Track delay
                if ecu_id not in ecu_delays:
                    ecu_delays[ecu_id] = []
                ecu_delays[ecu_id].append(resp.get('delay_ms', 0))

                # Detect padding byte
                if resp.get('frame_type') == 'single':
                    data = bytes.fromhex(resp['raw_data'].replace(' ', ''))
                    length = data[0] & 0x0F
                    if length < 7 and len(data) > length + 1:
                        pad_byte = data[-1]
                        ecu_padding[ecu_id] = f"0x{pad_byte:02X}"

        ecus = []
        for ecu_id in sorted(ecu_ids):
            ecu_index = int(ecu_id, 16) - 0x7E8
            avg_delay = sum(ecu_delays.get(ecu_id, [8])) / len(ecu_delays.get(ecu_id, [8]))

            ecus.append({
                'name': f"ECU_{ecu_index}",
                'index': ecu_index,
                'response_id': ecu_id,
                'physical_request_id': f"0x{0x7E0 + ecu_index:03X}",
                'padding_byte': ecu_padding.get(ecu_id, '0x00'),
                'response_delay_ms': round(avg_delay, 1)
            })

        return ecus

    def _extract_vin(self, responses):
        """Extract VIN from Service 09 PID 02 response."""
        key = (0x09, 0x02)
        if key not in responses:
            return None

        resp = responses[key]
        for ecu_id, r in resp['responses'].items():
            if r.get('frame_type') == 'multi':
                frames = r['raw_data']
                vin_bytes = []

                # First frame: bytes 5-7 (after 10 LL 49 02 01)
                ff_data = bytes.fromhex(frames[0].replace(' ', ''))
                vin_bytes.extend(ff_data[5:8])

                # Consecutive frames: bytes 1-7
                for cf in frames[1:]:
                    cf_data = bytes.fromhex(cf.replace(' ', ''))
                    vin_bytes.extend(cf_data[1:8])

                # VIN is 17 characters
                vin = bytes(vin_bytes[:17]).decode('ascii', errors='replace')
                return vin

        return None

    def _decode_vin(self, vin):
        """Decode VIN to extract vehicle info."""
        if not vin or len(vin) != 17:
            return {'vin': vin}

        # Basic VIN decoding
        wmi = vin[0:3]  # World Manufacturer Identifier
        vds = vin[3:9]  # Vehicle Descriptor Section
        vis = vin[9:17] # Vehicle Identifier Section

        # Year code (position 10)
        year_codes = {
            'A': 2010, 'B': 2011, 'C': 2012, 'D': 2013, 'E': 2014,
            'F': 2015, 'G': 2016, 'H': 2017, 'J': 2018, 'K': 2019,
            'L': 2020, 'M': 2021, 'N': 2022, 'P': 2023, 'R': 2024,
            'S': 2025
        }
        year = year_codes.get(vin[9], 0)

        # Manufacturer detection
        manufacturers = {
            'WBA': 'BMW', 'WBS': 'BMW M', '5UX': 'BMW',
            'WVW': 'Volkswagen', 'WAU': 'Audi',
            '1G1': 'Chevrolet', '1G6': 'Cadillac',
            '1FA': 'Ford', '1FM': 'Ford',
            '1HG': 'Honda', '5FN': 'Honda',
            'JHM': 'Honda', 'JTD': 'Toyota',
            '5TD': 'Toyota', '5TF': 'Toyota'
        }
        make = manufacturers.get(wmi, 'Unknown')

        return {
            'vin': vin,
            'make': make,
            'year': year,
            'wmi': wmi,
            'model': ''  # Would need model database
        }

    def _generate_profile_name(self, vehicle_info):
        """Generate a profile name from vehicle info."""
        make = vehicle_info.get('make', 'Unknown')
        model = vehicle_info.get('model', 'Vehicle')
        year = vehicle_info.get('year', '')
        return f"{make}_{model}_{year}".replace(' ', '_')

    def _calculate_timing(self, responses):
        """Calculate timing parameters from responses."""
        delays = []
        for (service, pid), resp_data in responses.items():
            for ecu_id, resp in resp_data['responses'].items():
                if 'delay_ms' in resp:
                    delays.append(resp['delay_ms'])

        if delays:
            return {
                'p2_response_ms': round(min(delays), 1),
                'p2_max_ms': round(max(delays), 1),
                'inter_ecu_delay_ms': 8
            }
        return {'p2_response_ms': 8, 'inter_ecu_delay_ms': 8}

    def _format_responses(self, responses):
        """Format responses into output structure."""
        output = {}

        for (service, pid), resp_data in responses.items():
            service_key = f"service_{service:02X}"
            if service_key not in output:
                output[service_key] = {}

            pid_key = f"0x{pid:02X}" if pid is not None else "request"

            entry = {
                'request': resp_data['raw_data']
            }

            # Add flow control if present
            if 'flow_control' in resp_data:
                entry['flow_control'] = resp_data['flow_control']

            # Add responses per ECU
            for ecu_id, resp in resp_data['responses'].items():
                if resp.get('frame_type') == 'multi':
                    entry[ecu_id] = {
                        'frames': resp['raw_data'],
                        'multi_frame': True,
                        'total_length': resp.get('total_length')
                    }
                else:
                    entry[ecu_id] = resp['raw_data']

            output[service_key][pid_key] = entry

        return output


def main():
    if len(sys.argv) < 2:
        print("Usage: python trace_parser.py <input.trc> [output.json]")
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else input_file.replace('.trc', '_profile.json')

    parser = TraceParser(input_file)
    parser.parse()
    profile = parser.generate_profile()

    with open(output_file, 'w') as f:
        json.dump(profile, f, indent=2)

    print(f"Profile generated: {output_file}")
    print(f"  VIN: {profile['vehicle_info'].get('vin', 'Not found')}")
    print(f"  ECUs: {len(profile['ecus'])}")
    print(f"  OBD2 PIDs: {sum(len(v) for v in profile['responses'].values())}")
    print(f"  Broadcast Messages: {len(profile['broadcast_messages'])}")


if __name__ == '__main__':
    main()
```

---

## 8. Example Extracted Data

### 8.1 Trace Comparison: Discovery vs PUI Mode

#### 8.1.1 Mode Detection Summary

| Attribute | BMW_OneStep.trc | BMW_PUI.trc |
|-----------|-----------------|-------------|
| **Operating Mode** | Discovery | PUI (Passive Until Interrogated) |
| **First Message Time** | 6.3ms | 65.3ms |
| **First OBD2 Request** | ~100ms | 11731.7ms |
| **Passive Phase Duration** | ~94ms | **11666.4ms** (~11.7 seconds) |
| **Query Pattern** | Sequential PID scan | Limited discovery + continuous polling |
| **Unique PIDs Queried** | 55+ | ~15 |
| **Total OBD2 Requests** | 55 | 60+ (many repeated) |
| **Continuously Polled PIDs** | None | 0x0C (RPM), 0x0D (Speed) |

#### 8.1.2 PUI Mode Phases (BMW_PUI.trc)

```
Phase 1: Passive Listening (0ms - 11731ms)
├── Broadcast messages only
├── 0x003C: 117 messages @ 100ms
├── 0x0130: 117 messages @ 100ms
├── 0x0799: 23 messages @ 500ms
└── 0x07C1: 11 messages @ 1000ms

Phase 2: Discovery (11731ms - 15000ms)
├── PID 0x00 (Supported PIDs 01-20)
├── PID 0x20 (Supported PIDs 21-40)
├── PID 0x40 (Supported PIDs 41-60)
├── PID 0x60 (Supported PIDs 61-80)
├── PID 0x80 (Supported PIDs 81-A0)
├── PID 0xA0 (Supported PIDs A1-C0)
└── Service 09 PID 0x02 (VIN)

Phase 3: Continuous Polling (15000ms - end)
├── RPM (0x0C): Polled every ~250ms, 20+ times
├── Speed (0x0D): Polled every ~500-750ms, 10+ times
├── Coolant Temp (0x05): Occasional
├── MAF (0x10): Occasional
├── Throttle (0x11): Occasional
└── Run Time (0x1F): Occasional
```

### 8.2 Request/Response Pairs from BMW_OneStep.trc

| Service | PID | Request | ECU 0x7E8 Response | ECU 0x7E9 Response | ECU 0x7EF Response |
|---------|-----|---------|-------------------|-------------------|-------------------|
| 01 | 00 | `02 01 00 00 00 00 00 00` | `06 41 00 BE 3F A8 13 00` | `06 41 00 98 18 80 01 AA` | `06 41 00 98 18 80 01 FF` |
| 01 | 01 | `02 01 01 00 00 00 00 00` | `06 41 01 00 07 E5 00 00` | `06 41 01 00 04 00 00 AA` | `06 41 01 00 04 00 00 FF` |
| 01 | 05 | `02 01 05 00 00 00 00 00` | `03 41 05 5B 00 00 00 00` | `03 41 05 5B AA AA AA AA` | `03 41 05 5B FF FF FF FF` |
| 01 | 0C | `02 01 0C 00 00 00 00 00` | `04 41 0C 0A 66 00 00 00` | `04 41 0C 0A 6C AA AA AA` | `04 41 0C 0A 6C FF FF FF` |
| 01 | 0D | `02 01 0D 00 00 00 00 00` | `03 41 0D 00 00 00 00 00` | `03 41 0D 00 AA AA AA AA` | `03 41 0D 00 FF FF FF FF` |
| 01 | 11 | `02 01 11 00 00 00 00 00` | `03 41 11 25 00 00 00 00` | `03 41 11 24 AA AA AA AA` | `03 41 11 24 FF FF FF FF` |
| 01 | 20 | `02 01 20 00 00 00 00 00` | `06 41 20 A0 07 B0 11 00` | `06 41 20 80 00 00 01 AA` | `06 41 20 80 00 00 01 FF` |
| 01 | 2F | `02 01 2F 00 00 00 00 00` | `03 41 2F 26 00 00 00 00` | - | - |
| 01 | 33 | `02 01 33 00 00 00 00 00` | `03 41 33 50 00 00 00 00` | - | - |
| 01 | 40 | `02 01 40 00 00 00 00 00` | `06 41 40 FE D0 84 11 00` | `06 41 40 C0 00 00 00 AA` | `06 41 40 C0 00 00 00 FF` |
| 01 | 46 | `02 01 46 00 00 00 00 00` | `03 41 46 2E 00 00 00 00` | - | - |
| 01 | 51 | `02 01 51 00 00 00 00 00` | `03 41 51 01 00 00 00 00` | - | - |
| 01 | 5C | `02 01 5C 00 00 00 00 00` | `03 41 5C 58 00 00 00 00` | - | - |
| 01 | 60 | `02 01 60 00 00 00 00 00` | `06 41 60 61 00 00 01 00` | - | - |
| 01 | 80 | `02 01 80 00 00 00 00 00` | `06 41 80 00 04 00 0D 00` | - | - |
| 01 | 9D | `02 01 9D 00 00 00 00 00` | `06 41 9D 00 0D 00 0D 00` | - | - |
| 01 | A0 | `02 01 A0 00 00 00 00 00` | `06 41 A0 04 00 00 00 00` | - | - |
| 01 | A6 | `02 01 A6 00 00 00 00 00` | `06 41 A6 00 14 53 8E 00` | - | - |
| 02 | 02 | `03 02 02 00 00 00 00 00` | `05 42 02 00 00 00 00 00` | `05 42 02 00 00 00 AA AA` | `05 42 02 00 00 00 FF FF` |
| 03 | - | `01 03 00 00 00 00 00 00` | `02 43 00 00 00 00 00 00` | `02 43 00 AA AA AA AA AA` | `02 43 00 FF FF FF FF FF` |
| 07 | - | `01 07 00 00 00 00 00 00` | `02 47 00 00 00 00 00 00` | `02 47 00 AA AA AA AA AA` | `02 47 00 FF FF FF FF FF` |
| 09 | 02 | `02 09 02 00 00 00 00 00` | Multi-frame (see below) | - | - |
| 0A | - | `01 0A 00 00 00 00 00 00` | `02 4A 00 00 00 00 00 00` | `02 4A 00 AA AA AA AA AA` | `02 4A 00 FF FF FF FF FF` |

### 8.3 Dynamic Values from BMW_PUI.trc (Continuous Polling)

The PUI trace shows repeated queries to the same PIDs with varying values. The parser must track these:

#### 8.3.1 Engine RPM (PID 0x0C) - Continuously Polled

| Query # | Time (ms) | ECU 0x7E8 | ECU 0x7E9 | ECU 0x7EF | Decoded RPM (7E8) |
|---------|-----------|-----------|-----------|-----------|-------------------|
| 1 | 16265.8 | `04 41 0C 0A 7A` | `04 41 0C 0A 54` | `04 41 0C 0A 50` | 669.5 |
| 2 | 17516.0 | `04 41 0C 0A 64` | `04 41 0C 0A 68` | `04 41 0C 0A 68` | 665.0 |
| 3 | 18766.4 | `04 41 0C 0A 72` | `04 41 0C 0A 58` | `04 41 0C 0A 50` | 668.5 |
| 4 | 20015.8 | `04 41 0C 0A 5C` | `04 41 0C 0A 5C` | `04 41 0C 0A 5C` | 663.0 |
| 5 | 21265.8 | `04 41 0C 0A 38` | `04 41 0C 0A 3C` | `04 41 0C 0A 3C` | 654.0 |
| ... | ... | ... | ... | ... | ... |

**Polling Analysis:**
- Query count: 20+
- Average interval: ~1250ms
- Pattern: Continuous polling

**Value Range (ECU 0x7E8):**
- Raw min: 0x0A2E (2606) → 651.5 RPM
- Raw max: 0x0A7C (2684) → 671.0 RPM
- Indicates idle RPM

#### 8.3.2 Vehicle Speed (PID 0x0D) - Continuously Polled

| Query # | Time (ms) | ECU 0x7E8 | ECU 0x7E9 | ECU 0x7EF | Decoded Speed |
|---------|-----------|-----------|-----------|-----------|---------------|
| 1 | 17265.8 | `03 41 0D 00` | `03 41 0D 00` | `03 41 0D 00` | 0 km/h |
| 2 | 19515.8 | `03 41 0D 00` | `03 41 0D 00` | `03 41 0D 00` | 0 km/h |
| 3 | 21765.9 | `03 41 0D 00` | `03 41 0D 00` | `03 41 0D 00` | 0 km/h |
| ... | ... | ... | ... | ... | ... |

**Polling Analysis:**
- Query count: 10+
- Average interval: ~2250ms
- Pattern: Continuous polling
- All values: 0 (vehicle stationary)

#### 8.3.3 Other PIDs in BMW_PUI.trc

| PID | Query Count | Pattern | Sample Values |
|-----|-------------|---------|---------------|
| 0x05 (Coolant Temp) | 1 | Single query | 0x5D (53°C) |
| 0x10 (MAF Rate) | 1 | Single query | 0x018D (3.97 g/s) |
| 0x11 (Throttle) | 1 | Single query | 0x25 (14.5%) |
| 0x1F (Run Time) | 2 | Sporadic | 0x011C, 0x0128 (284s, 296s) |

### 8.4 VIN Multi-Frame Sequence

```
Request:    0x7DF: 02 09 02 00 00 00 00 00
Response 1: 0x7E8: 10 14 49 02 01 35 55 58   (First Frame)
Tester:     0x7E0: 30 00 00 00 00 00 00 00   (Flow Control)
Response 2: 0x7E8: 21 54 53 33 43 35 58 4B   (Consecutive Frame 1)
Response 3: 0x7E8: 22 30 5A 30 32 36 35 36   (Consecutive Frame 2)

Decoded VIN: 5UXTS3C5XK0Z02656
```

### 8.3 Broadcast Messages

| CAN ID | Interval | DLC | Pattern | Sample Data |
|--------|----------|-----|---------|-------------|
| 0x003C | 100 ms | 8 | Rolling counter | `AF A1 02 12 01 00 2A FF` |
| 0x0130 | 100 ms | 5 | Static | `F7 FF FF FF FF` |
| 0x0799 | 500 ms | 7 | Rolling counter | `1B 01 16 04 12 03 0A` |
| 0x07C1 | 1000 ms | 8 | Static | `0C 18 00 0C FF 00 01 00` |

#### Detailed Broadcast Analysis: 0x003C

```
Sample Sequence:
  AF A1 02 12 01 00 2A FF   (counter = 0xA1)
  48 A2 02 12 01 00 2A FF   (counter = 0xA2)
  15 A3 02 12 01 00 2A FF   (counter = 0xA3)
  9B A4 02 12 01 00 2A FF   (counter = 0xA4)
  C6 A5 02 12 01 00 2A FF   (counter = 0xA5)
  21 A6 02 12 01 00 2A FF   (counter = 0xA6)
  7C A7 02 12 01 00 2A FF   (counter = 0xA7)
  20 A8 02 12 01 00 2A FF   (counter = 0xA8)
  7D A9 02 12 01 00 2A FF   (counter = 0xA9)
  9A AA 02 12 01 00 2A FF   (counter = 0xAA)
  C7 AB 02 12 01 00 2A FF   (counter = 0xAB)
  49 AC 02 12 01 00 2A FF   (counter = 0xAC)
  14 AD 02 12 01 00 2A FF   (counter = 0xAD)
  F3 AE 02 12 01 00 2A FF   (counter = 0xAE)
  F2 A0 02 12 01 00 2A FF   (counter = 0xA0, wraps)

Analysis:
  Byte 0: Checksum (varies based on counter)
  Byte 1: Rolling counter 0xA0-0xAF (16 values, wraps)
  Bytes 2-7: Static: 02 12 01 00 2A FF
```

#### Detailed Broadcast Analysis: 0x0799

```
Sample Sequence:
  1B 01 16 04 12 03 0A
  1D 01 16 04 10 03 0A
  1A 01 16 04 12 03 0A
  1C 01 16 04 11 03 0A
  1E 01 16 04 0F 03 0A
  19 01 16 04 13 03 0A
  1F 01 16 04 0E 03 0A

Analysis:
  Byte 0: Counter 0x18-0x1F (8 values)
  Byte 1: Static: 0x01
  Byte 2: Static: 0x16 (sometimes 0x17)
  Byte 3: Static: 0x04
  Byte 4: Varies: 0x0E-0x13
  Byte 5: Static: 0x03
  Byte 6: Static: 0x0A
```

---

## 9. Testing & Validation

### 9.1 Parser Test Cases

1. **Basic Parsing**: Parse trace, verify message count matches
2. **OBD2 Detection**: Verify all 0x7DF requests are captured
3. **Multi-ECU**: Confirm responses from all ECUs are associated
4. **Multi-Frame**: Verify VIN is correctly reassembled
5. **Broadcast Detection**: Verify static/dynamic patterns detected
6. **Timing Accuracy**: Validate response delay calculations

### 9.2 Profile Validation

```python
def validate_profile(profile):
    """Validate generated profile structure."""
    errors = []

    # Required fields
    required = ['profile_version', 'vehicle_info', 'responses']
    for field in required:
        if field not in profile:
            errors.append(f"Missing required field: {field}")

    # VIN format
    vin = profile.get('vehicle_info', {}).get('vin', '')
    if vin and len(vin) != 17:
        errors.append(f"Invalid VIN length: {len(vin)}")

    # Response format
    for service, pids in profile.get('responses', {}).items():
        for pid, entry in pids.items():
            if 'request' not in entry:
                errors.append(f"Missing request for {service}/{pid}")

            # Verify at least one response
            has_response = any(k.startswith('0x7E') for k in entry.keys())
            if not has_response:
                errors.append(f"No responses for {service}/{pid}")

    return errors
```

---

## 10. Command-Line Interface

### 10.1 Usage

```bash
# Basic usage
python trace_parser.py BMW_OneStep.trc

# Specify output file
python trace_parser.py BMW_OneStep.trc profiles/BMW_X3_2019.json

# Verbose output
python trace_parser.py -v BMW_OneStep.trc

# Validate only (no output file)
python trace_parser.py --validate BMW_OneStep.trc

# Extract specific service only
python trace_parser.py --service 01 BMW_OneStep.trc
```

### 10.2 Expected Output

#### 10.2.1 Discovery Mode Trace (BMW_OneStep.trc)

```
$ python trace_parser.py BMW_OneStep.trc

Parsing: BMW_OneStep.trc
  File version: 1.1
  Start time: 2025-12-13 11:40:28.911000
  Generator: PCAN-View v5.3.2.952

Processing 1116 messages...
  OBD2 Requests: 55
  OBD2 Responses: 117
  Broadcast Messages: 943

Trace Analysis:
  Operating Mode: DISCOVERY
  Passive Phase: 94ms (immediate OBD2 traffic)
  First OBD2 Request: 100ms
  Query Pattern: Sequential PID enumeration

Extracting request/response pairs...
  Service 01: 18 PIDs
  Service 02: 1 PID
  Service 03: 1 request
  Service 07: 1 request
  Service 09: 1 PID
  Service 0A: 1 request

Analyzing broadcast messages...
  0x003C: 410 occurrences, 100ms interval, dynamic pattern
  0x0130: 410 occurrences, 100ms interval, static pattern
  0x0799: 82 occurrences, 500ms interval, dynamic pattern
  0x07C1: 41 occurrences, 1000ms interval, static pattern

Vehicle identified:
  VIN: 5UXTS3C5XK0Z02656
  Make: BMW
  Year: 2019

ECUs detected:
  0x7E8: Primary (padding: 0x00, delay: 6.2ms)
  0x7E9: Secondary (padding: 0xAA, delay: 14.5ms)
  0x7EF: Tertiary (padding: 0xFF, delay: 22.8ms)

Profile generated: BMW_OneStep_profile.json
```

#### 10.2.2 PUI Mode Trace (BMW_PUI.trc)

```
$ python trace_parser.py BMW_PUI.trc

Parsing: BMW_PUI.trc
  File version: 1.1
  Start time: 2025-12-13 11:41:47.210000
  Generator: PCAN-View v5.3.2.952

Processing 1117 messages...
  OBD2 Requests: 62
  OBD2 Responses: 142
  Broadcast Messages: 913

Trace Analysis:
  Operating Mode: PUI (Passive Until Interrogated)
  Passive Phase: 11666ms (~11.7 seconds)
  First OBD2 Request: 11731ms
  Query Pattern: Limited discovery + continuous polling

Polling Pattern Analysis:
  PID 0x0C (RPM): 20 queries, avg interval 1250ms, CONTINUOUS
  PID 0x0D (Speed): 10 queries, avg interval 2250ms, CONTINUOUS
  PID 0x00 (Supported): 2 queries, SPORADIC
  PID 0x1F (Run Time): 2 queries, SPORADIC
  Other PIDs: Single query each

Dynamic Value Tracking:
  PID 0x0C (RPM):
    ECU 0x7E8: 20 samples, range 0x0A2E-0x0A7C (651.5-671.0 RPM)
    ECU 0x7E9: 20 samples, range 0x0A34-0x0A74 (652.0-670.0 RPM)
    ECU 0x7EF: 20 samples, range 0x0A34-0x0A74 (652.0-670.0 RPM)
  PID 0x0D (Speed):
    All ECUs: Constant 0x00 (0 km/h - vehicle stationary)

Extracting request/response pairs...
  Service 01: 15 PIDs (6 polled repeatedly)
  Service 09: 1 PID

Analyzing broadcast messages...
  0x003C: 407 occurrences, 100ms interval, dynamic pattern
  0x0130: 407 occurrences, 100ms interval, static pattern
  0x0799: 80 occurrences, 500ms interval, dynamic pattern
  0x07C1: 40 occurrences, 1000ms interval, static pattern

Vehicle identified:
  VIN: 5UXTS3C5XK0Z02656
  Make: BMW
  Year: 2019

ECUs detected:
  0x7E8: Primary (padding: 0x00, delay: 6.2ms)
  0x7E9: Secondary (padding: 0xAA, delay: 14.5ms)
  0x7EF: Tertiary (padding: 0xFF, delay: 22.8ms)

Profile generated: BMW_PUI_profile.json
```

---

## Appendix A: OBD2 Service Reference

| Service | Name | Request Format | Response Format |
|---------|------|----------------|-----------------|
| 0x01 | Current Data | `02 01 PID 00 00 00 00 00` | `LL 41 PID DATA...` |
| 0x02 | Freeze Frame | `03 02 PID FF 00 00 00 00` | `LL 42 PID DATA...` |
| 0x03 | Stored DTCs | `01 03 00 00 00 00 00 00` | `LL 43 DTC1 DTC2...` |
| 0x04 | Clear DTCs | `01 04 00 00 00 00 00 00` | `01 44` |
| 0x07 | Pending DTCs | `01 07 00 00 00 00 00 00` | `LL 47 DTC1 DTC2...` |
| 0x09 | Vehicle Info | `02 09 PID 00 00 00 00 00` | Multi-frame |
| 0x0A | Permanent DTCs | `01 0A 00 00 00 00 00 00` | `LL 4A DTC1 DTC2...` |

---

## Appendix B: Common PID Formulas

| PID | Name | Bytes | Formula | Unit |
|-----|------|-------|---------|------|
| 0x05 | Coolant Temp | 1 | A - 40 | °C |
| 0x0C | Engine RPM | 2 | (256A + B) / 4 | rpm |
| 0x0D | Vehicle Speed | 1 | A | km/h |
| 0x0F | Intake Air Temp | 1 | A - 40 | °C |
| 0x10 | MAF Rate | 2 | (256A + B) / 100 | g/s |
| 0x11 | Throttle Position | 1 | A * 100 / 255 | % |
| 0x2F | Fuel Level | 1 | A * 100 / 255 | % |
| 0x33 | Baro Pressure | 1 | A | kPa |
| 0x46 | Ambient Temp | 1 | A - 40 | °C |
| 0x5C | Oil Temp | 1 | A - 40 | °C |
| 0xA6 | Odometer | 4 | (A<<24 + B<<16 + C<<8 + D) / 10 | km |

---

**Document End**
